<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MolDyPoP: group Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="mperp_200.png"/></td>
  <td id="projectalign">
   <div id="projectname">MolDyPoP<span id="projectnumber">&#160;Version 2.0</span>
   </div>
   <div id="projectbrief">Molecular Dynamics for Polar Particle</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classgroup-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">group Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>A group of polar particles. Stores vectors with particle positions, velocities, spin orientations and spin rotation velocity, as well as further group properties.  
 <a href="classgroup.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="group_8h_source.html">group.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad9d5836aea085e5b55ecb077d15a6189"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#ad9d5836aea085e5b55ecb077d15a6189">group</a> ()</td></tr>
<tr class="separator:ad9d5836aea085e5b55ecb077d15a6189"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af20a8ed575914e6ee1a2d3b0504633e7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#af20a8ed575914e6ee1a2d3b0504633e7">group</a> (const <a class="el" href="classparameters.html">parameters</a> &amp;par)</td></tr>
<tr class="memdesc:af20a8ed575914e6ee1a2d3b0504633e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor from values stored in parameters. Only sets simulation parameters, does not initialize particle data.  <br /></td></tr>
<tr class="separator:af20a8ed575914e6ee1a2d3b0504633e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf8ae64992b806f704a91c5ec33d8047"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#acf8ae64992b806f704a91c5ec33d8047">group</a> (const int N, const std::string group_type)</td></tr>
<tr class="memdesc:acf8ae64992b806f704a91c5ec33d8047"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduced constructor, useful for time derivative group.  <br /></td></tr>
<tr class="separator:acf8ae64992b806f704a91c5ec33d8047"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a05c6a033e70fc0bee898b55af1eb2d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#a9a05c6a033e70fc0bee898b55af1eb2d">clear</a> ()</td></tr>
<tr class="memdesc:a9a05c6a033e70fc0bee898b55af1eb2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears particles and partition.  <br /></td></tr>
<tr class="separator:a9a05c6a033e70fc0bee898b55af1eb2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c5201fa5923681c881093cac8ba27f2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#a7c5201fa5923681c881093cac8ba27f2">initialize</a> (const <a class="el" href="classparameters.html">parameters</a> &amp;par)</td></tr>
<tr class="memdesc:a7c5201fa5923681c881093cac8ba27f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes particle data for the group based on parameters given.  <br /></td></tr>
<tr class="separator:a7c5201fa5923681c881093cac8ba27f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19ea7b028ce3882369b633f818baeb79"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#a19ea7b028ce3882369b633f818baeb79">initialize_random</a> (double kbT=0)</td></tr>
<tr class="memdesc:a19ea7b028ce3882369b633f818baeb79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the mobile group with random particle positions and fills the partition.  <br /></td></tr>
<tr class="separator:a19ea7b028ce3882369b633f818baeb79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a382d6fd08520e962a201f12d12784d96"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#a382d6fd08520e962a201f12d12784d96">randomize_particles</a> (double kbT=0)</td></tr>
<tr class="memdesc:a382d6fd08520e962a201f12d12784d96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets particles to random values.  <br /></td></tr>
<tr class="separator:a382d6fd08520e962a201f12d12784d96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0636f5f5df62b94d68b16d0783ba9db8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#a0636f5f5df62b94d68b16d0783ba9db8">mom_to_zero</a> ()</td></tr>
<tr class="memdesc:a0636f5f5df62b94d68b16d0783ba9db8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets momenta to zero by shifts.  <br /></td></tr>
<tr class="separator:a0636f5f5df62b94d68b16d0783ba9db8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7314ed0367730dd255506ef24e044d9f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#a7314ed0367730dd255506ef24e044d9f">r_to_squarelattice</a> ()</td></tr>
<tr class="memdesc:a7314ed0367730dd255506ef24e044d9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets positions to square lattice.  <br /></td></tr>
<tr class="separator:a7314ed0367730dd255506ef24e044d9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a048b170c8a1a823912103a846ac1e100"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#a048b170c8a1a823912103a846ac1e100">r_to_trigonallattice</a> ()</td></tr>
<tr class="memdesc:a048b170c8a1a823912103a846ac1e100"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets positions to trigonal lattice. CAREFUL! Trigonal lattice does not fit well into square box.  <br /></td></tr>
<tr class="separator:a048b170c8a1a823912103a846ac1e100"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8af680389fbe26cb2b6f98ba03b5628b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#a8af680389fbe26cb2b6f98ba03b5628b">r_to_lattice</a> ()</td></tr>
<tr class="memdesc:a8af680389fbe26cb2b6f98ba03b5628b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets positions to lattice. Decides which lattice depending on lattice_type_ member variable.  <br /></td></tr>
<tr class="separator:a8af680389fbe26cb2b6f98ba03b5628b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cde85b83583a5335dd4b422b690ab88"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#a1cde85b83583a5335dd4b422b690ab88">initialize_zero</a> ()</td></tr>
<tr class="memdesc:a1cde85b83583a5335dd4b422b690ab88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets all particles to zero.  <br /></td></tr>
<tr class="separator:a1cde85b83583a5335dd4b422b690ab88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cd4f3e5a31ec3a4f19e7fe0655b2316"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#a2cd4f3e5a31ec3a4f19e7fe0655b2316">fill_partition</a> ()</td></tr>
<tr class="memdesc:a2cd4f3e5a31ec3a4f19e7fe0655b2316"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills, i.e. computes the partition.  <br /></td></tr>
<tr class="separator:a2cd4f3e5a31ec3a4f19e7fe0655b2316"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4ee4dd785e2ba8a4167d8e82744cc68"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#af4ee4dd785e2ba8a4167d8e82744cc68">read_from_snapshot</a> (std::string snapshotname)</td></tr>
<tr class="memdesc:af4ee4dd785e2ba8a4167d8e82744cc68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads coordinates and momenta from file snapshotname.  <br /></td></tr>
<tr class="separator:af4ee4dd785e2ba8a4167d8e82744cc68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae039bc5e8e6d4c72cdc4883b7bebfe44"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#ae039bc5e8e6d4c72cdc4883b7bebfe44">scale_from_subgroup</a> (const <a class="el" href="classgroup.html">group</a> &amp;G)</td></tr>
<tr class="memdesc:ae039bc5e8e6d4c72cdc4883b7bebfe44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes a subgroup (smaller group) and scales it up to the correct size of the group by copying.  <br /></td></tr>
<tr class="separator:ae039bc5e8e6d4c72cdc4883b7bebfe44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a736194a121584082de439cbcc4212007"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#a736194a121584082de439cbcc4212007">scale_from_subgroup</a> (std::string snapshotname)</td></tr>
<tr class="memdesc:a736194a121584082de439cbcc4212007"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a subgroup (smaller group) from a file and scales it up to the correct size of the group by copying.  <br /></td></tr>
<tr class="separator:a736194a121584082de439cbcc4212007"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a245820fd75c41adc4bde3d49064d4763"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#a245820fd75c41adc4bde3d49064d4763">print_group</a> (std::ofstream &amp;outputfile) const</td></tr>
<tr class="memdesc:a245820fd75c41adc4bde3d49064d4763"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the entire group to the outputfile.  <br /></td></tr>
<tr class="separator:a245820fd75c41adc4bde3d49064d4763"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86c12b188ea422afd8c14fdfd7ac8614"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#a86c12b188ea422afd8c14fdfd7ac8614">print_r</a> (std::ofstream &amp;outputfile) const</td></tr>
<tr class="memdesc:a86c12b188ea422afd8c14fdfd7ac8614"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints only position coordinates of group to the outputfile.  <br /></td></tr>
<tr class="separator:a86c12b188ea422afd8c14fdfd7ac8614"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0af365fff45f5342e94fee665b09fe38"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#a0af365fff45f5342e94fee665b09fe38">get_N</a> () const</td></tr>
<tr class="memdesc:a0af365fff45f5342e94fee665b09fe38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns number of particles.  <br /></td></tr>
<tr class="separator:a0af365fff45f5342e94fee665b09fe38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac79ce6a5e76f29bd75c1c533fa22059e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#ac79ce6a5e76f29bd75c1c533fa22059e">size</a> () const</td></tr>
<tr class="memdesc:ac79ce6a5e76f29bd75c1c533fa22059e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="classgroup.html#a0af365fff45f5342e94fee665b09fe38" title="Returns number of particles.">get_N()</a>  <br /></td></tr>
<tr class="separator:ac79ce6a5e76f29bd75c1c533fa22059e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a720506c44b273c3f667101135cc4ec0f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#a720506c44b273c3f667101135cc4ec0f">get_sqrtN</a> () const</td></tr>
<tr class="memdesc:a720506c44b273c3f667101135cc4ec0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns sqrt of number of particles.  <br /></td></tr>
<tr class="separator:a720506c44b273c3f667101135cc4ec0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a809cb802277ce088d2dbc7ccb1531f4b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtopology_1_1_vector2d.html">topology::Vector2d</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#a809cb802277ce088d2dbc7ccb1531f4b">get_L</a> () const</td></tr>
<tr class="memdesc:a809cb802277ce088d2dbc7ccb1531f4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns simulation box size.  <br /></td></tr>
<tr class="separator:a809cb802277ce088d2dbc7ccb1531f4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08b7dfd53858616e08da206455e6df5d"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#a08b7dfd53858616e08da206455e6df5d">get_boxsize</a> () const</td></tr>
<tr class="memdesc:a08b7dfd53858616e08da206455e6df5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns smallest box length.  <br /></td></tr>
<tr class="separator:a08b7dfd53858616e08da206455e6df5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bde066b964a18a6866268119665d2db"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#a7bde066b964a18a6866268119665d2db">get_volume</a> () const</td></tr>
<tr class="memdesc:a7bde066b964a18a6866268119665d2db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns volume.  <br /></td></tr>
<tr class="separator:a7bde066b964a18a6866268119665d2db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff2998a96bff57f7b721de7ceef1141f"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#aff2998a96bff57f7b721de7ceef1141f">get_density</a> () const</td></tr>
<tr class="memdesc:aff2998a96bff57f7b721de7ceef1141f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns density.  <br /></td></tr>
<tr class="separator:aff2998a96bff57f7b721de7ceef1141f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af959f8b307677c95e4b3271f5d6abead"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#af959f8b307677c95e4b3271f5d6abead">get_I</a> () const</td></tr>
<tr class="memdesc:af959f8b307677c95e4b3271f5d6abead"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns member variable I_ (spin inertia)  <br /></td></tr>
<tr class="separator:af959f8b307677c95e4b3271f5d6abead"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6ba547117763b24a0d341fa258fcfd7"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#ae6ba547117763b24a0d341fa258fcfd7">get_J</a> () const</td></tr>
<tr class="memdesc:ae6ba547117763b24a0d341fa258fcfd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns member variable J_ (spin coupling strength)  <br /></td></tr>
<tr class="separator:ae6ba547117763b24a0d341fa258fcfd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a614dc2b2a83fa117ee37b0186b99aae5"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#a614dc2b2a83fa117ee37b0186b99aae5">get_m</a> () const</td></tr>
<tr class="memdesc:a614dc2b2a83fa117ee37b0186b99aae5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns member variable m_ (particle mass)  <br /></td></tr>
<tr class="separator:a614dc2b2a83fa117ee37b0186b99aae5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77bd98604ac648bbac5198554cf50a79"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#a77bd98604ac648bbac5198554cf50a79">get_cutoff</a> () const</td></tr>
<tr class="memdesc:a77bd98604ac648bbac5198554cf50a79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns member variable cutoff_ (interaction cutoff length)  <br /></td></tr>
<tr class="separator:a77bd98604ac648bbac5198554cf50a79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a830fc560e181d89475bee4743e7f64ff"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#a830fc560e181d89475bee4743e7f64ff">get_vm_v</a> () const</td></tr>
<tr class="memdesc:a830fc560e181d89475bee4743e7f64ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns member variable vm_v_ (Vicsek model velocity)  <br /></td></tr>
<tr class="separator:a830fc560e181d89475bee4743e7f64ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33626d82a7a15069d7263b95a78ca879"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#a33626d82a7a15069d7263b95a78ca879">get_vm_eta</a> () const</td></tr>
<tr class="memdesc:a33626d82a7a15069d7263b95a78ca879"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns member variable vm_eta_ (Vicsek model noise strength)  <br /></td></tr>
<tr class="separator:a33626d82a7a15069d7263b95a78ca879"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18cf499bb765b4424803af9c9d3345e7"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#a18cf499bb765b4424803af9c9d3345e7">get_group_type</a> () const</td></tr>
<tr class="memdesc:a18cf499bb765b4424803af9c9d3345e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns member variable group_type_ (type of group)  <br /></td></tr>
<tr class="separator:a18cf499bb765b4424803af9c9d3345e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2012999a47b966f17c0cfff96a61ce69"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#a2012999a47b966f17c0cfff96a61ce69">get_theta</a> () const</td></tr>
<tr class="memdesc:a2012999a47b966f17c0cfff96a61ce69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns member vector theta_ (spin angles). Length N.  <br /></td></tr>
<tr class="separator:a2012999a47b966f17c0cfff96a61ce69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04807e043673e16cc7dd41bc6a702e1c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#a04807e043673e16cc7dd41bc6a702e1c">get_w</a> () const</td></tr>
<tr class="memdesc:a04807e043673e16cc7dd41bc6a702e1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns member vector w_ (spin momenta). Length N.  <br /></td></tr>
<tr class="separator:a04807e043673e16cc7dd41bc6a702e1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe6b300a0569a60ed251d53f696ba403"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classtopology_1_1_vector2d.html">topology::Vector2d</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#afe6b300a0569a60ed251d53f696ba403">get_r</a> () const</td></tr>
<tr class="memdesc:afe6b300a0569a60ed251d53f696ba403"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns member vector r_ (positions). Length N.  <br /></td></tr>
<tr class="separator:afe6b300a0569a60ed251d53f696ba403"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad288525b31316ed5142d1ef6ab4c5115"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classtopology_1_1_vector2d.html">topology::Vector2d</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#ad288525b31316ed5142d1ef6ab4c5115">get_p</a> () const</td></tr>
<tr class="memdesc:ad288525b31316ed5142d1ef6ab4c5115"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns member vector p_ (linear momenta). Length N.  <br /></td></tr>
<tr class="separator:ad288525b31316ed5142d1ef6ab4c5115"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8b7b1e77febb8a2afd245304358009e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#ad8b7b1e77febb8a2afd245304358009e">get_coord</a> () const</td></tr>
<tr class="memdesc:ad8b7b1e77febb8a2afd245304358009e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns vector of all coordinates (angles theta_ and poitions r_, length 3N)  <br /></td></tr>
<tr class="separator:ad8b7b1e77febb8a2afd245304358009e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae360d6121e189e51b55e529f9a074c07"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#ae360d6121e189e51b55e529f9a074c07">get_mom</a> () const</td></tr>
<tr class="memdesc:ae360d6121e189e51b55e529f9a074c07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns vector of all momenta (spin momenta w_ and linear momenta p_, length 3N)  <br /></td></tr>
<tr class="separator:ae360d6121e189e51b55e529f9a074c07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d976ade405763f16dc7c3af8ea45e6f"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#a7d976ade405763f16dc7c3af8ea45e6f">get_theta</a> (int i) const</td></tr>
<tr class="memdesc:a7d976ade405763f16dc7c3af8ea45e6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns spin angle theta_[i] of particle i.  <br /></td></tr>
<tr class="separator:a7d976ade405763f16dc7c3af8ea45e6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3e9c6c12977ede28d24ddd636f87eaa"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#aa3e9c6c12977ede28d24ddd636f87eaa">get_w</a> (int i) const</td></tr>
<tr class="memdesc:aa3e9c6c12977ede28d24ddd636f87eaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns spin momentum w_[i] of particle i.  <br /></td></tr>
<tr class="separator:aa3e9c6c12977ede28d24ddd636f87eaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30b3c2277645a89660dcd569fd88128f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtopology_1_1_vector2d.html">topology::Vector2d</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#a30b3c2277645a89660dcd569fd88128f">get_r</a> (int i) const</td></tr>
<tr class="memdesc:a30b3c2277645a89660dcd569fd88128f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns position r_[i] of particle i.  <br /></td></tr>
<tr class="separator:a30b3c2277645a89660dcd569fd88128f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cdc0f913566c1551ec6c2a48ce7ea84"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtopology_1_1_vector2d.html">topology::Vector2d</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#a0cdc0f913566c1551ec6c2a48ce7ea84">get_p</a> (int i) const</td></tr>
<tr class="memdesc:a0cdc0f913566c1551ec6c2a48ce7ea84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns linear momentum p_[i] of particle i.  <br /></td></tr>
<tr class="separator:a0cdc0f913566c1551ec6c2a48ce7ea84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67f44a5b6756ace3cb9189b43048b4d2"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#a67f44a5b6756ace3cb9189b43048b4d2">J_pot</a> (double dist) const</td></tr>
<tr class="memdesc:a67f44a5b6756ace3cb9189b43048b4d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns spin interaction potential (distance-dependence)  <br /></td></tr>
<tr class="separator:a67f44a5b6756ace3cb9189b43048b4d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55e9bf8a5f8b9f1ee0b378f0ca2cfae0"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#a55e9bf8a5f8b9f1ee0b378f0ca2cfae0">U_pot</a> (double dist) const</td></tr>
<tr class="memdesc:a55e9bf8a5f8b9f1ee0b378f0ca2cfae0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns spatial interaction potential.  <br /></td></tr>
<tr class="separator:a55e9bf8a5f8b9f1ee0b378f0ca2cfae0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eb41a26ccb0d9ff0a675b2cf93c9e07"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#a0eb41a26ccb0d9ff0a675b2cf93c9e07">J_pot_prime</a> (double dist) const</td></tr>
<tr class="memdesc:a0eb41a26ccb0d9ff0a675b2cf93c9e07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns derivative of spin interaction potential (distance-dependence)  <br /></td></tr>
<tr class="separator:a0eb41a26ccb0d9ff0a675b2cf93c9e07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a869674c0af745152011e6d628430dec2"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#a869674c0af745152011e6d628430dec2">U_pot_prime</a> (double dist) const</td></tr>
<tr class="memdesc:a869674c0af745152011e6d628430dec2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns derivative of spatial interaction potential.  <br /></td></tr>
<tr class="separator:a869674c0af745152011e6d628430dec2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3a2b18c61a0d5d6b49d82e2ee968a14"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#ab3a2b18c61a0d5d6b49d82e2ee968a14">J_pot_primeprime</a> (double dist) const</td></tr>
<tr class="memdesc:ab3a2b18c61a0d5d6b49d82e2ee968a14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns second derivative of spin interaction potential (distance-dependence)  <br /></td></tr>
<tr class="separator:ab3a2b18c61a0d5d6b49d82e2ee968a14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76800935f2839e0e3f22b4910412ebec"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#a76800935f2839e0e3f22b4910412ebec">U_pot_primeprime</a> (double dist) const</td></tr>
<tr class="memdesc:a76800935f2839e0e3f22b4910412ebec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns second derivative of spatial interaction potential.  <br /></td></tr>
<tr class="separator:a76800935f2839e0e3f22b4910412ebec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e09f2d17d963087ef510ea37ff7d17b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#a8e09f2d17d963087ef510ea37ff7d17b">get_neighbors</a> (int i, std::string cellselect, std::vector&lt; double &gt; &amp;distances) const</td></tr>
<tr class="memdesc:a8e09f2d17d963087ef510ea37ff7d17b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns indices of neighbors of the particle. Selection of cells possible.  <br /></td></tr>
<tr class="separator:a8e09f2d17d963087ef510ea37ff7d17b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f64beec448f2ed67848f5886250c966"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#a8f64beec448f2ed67848f5886250c966">get_neighbors</a> (int i, std::vector&lt; double &gt; &amp;distances) const</td></tr>
<tr class="memdesc:a8f64beec448f2ed67848f5886250c966"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns indices of neighbors of the particle. Uses the member variable nb_rule_ to determine which cells to select.  <br /></td></tr>
<tr class="separator:a8f64beec448f2ed67848f5886250c966"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fc0be012241fcee2de13909bdfb1e3e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#a2fc0be012241fcee2de13909bdfb1e3e">generate_neighbor_list</a> ()</td></tr>
<tr class="memdesc:a2fc0be012241fcee2de13909bdfb1e3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills the variables nb_index_, nb_first_, nb_dist_ according to the current neighborhood situation. Strongly recommended for fmxy model, recommended for xy and fvm model with small system sizes.  <br /></td></tr>
<tr class="separator:a2fc0be012241fcee2de13909bdfb1e3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a278395747b1e8982e081e3af5fedcb75"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#a278395747b1e8982e081e3af5fedcb75">theta_diff</a> (int i, int j) const</td></tr>
<tr class="memdesc:a278395747b1e8982e081e3af5fedcb75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Difference in angles of two different particles. $\theta_{ij}$ in Bore paper.  <br /></td></tr>
<tr class="separator:a278395747b1e8982e081e3af5fedcb75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a39ffd1d945d3b2e29644cd8071c8d3"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#a9a39ffd1d945d3b2e29644cd8071c8d3">periodic_distance_squared</a> (int i, int j) const</td></tr>
<tr class="memdesc:a9a39ffd1d945d3b2e29644cd8071c8d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns squared distance between particle i and j considering periodic boundaries (square box). Squared function faster to calculate.  <br /></td></tr>
<tr class="separator:a9a39ffd1d945d3b2e29644cd8071c8d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83cf3a22bf14d9583457f4a570095487"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#a83cf3a22bf14d9583457f4a570095487">periodic_distance</a> (int i, int j) const</td></tr>
<tr class="memdesc:a83cf3a22bf14d9583457f4a570095487"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns distance between particle i and j considering periodic boundaries (square box). Taking sqrt takes more time than returning the squared quantity by dist_periodic_squared.  <br /></td></tr>
<tr class="separator:a83cf3a22bf14d9583457f4a570095487"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2ac63201784cc0fe10ffec2f43dd502"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtopology_1_1_vector2d.html">topology::Vector2d</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#ad2ac63201784cc0fe10ffec2f43dd502">periodic_distance_vector</a> (int i, int j) const</td></tr>
<tr class="memdesc:ad2ac63201784cc0fe10ffec2f43dd502"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns distance vector between particle i and j considering periodic boundaries (square box).  <br /></td></tr>
<tr class="separator:ad2ac63201784cc0fe10ffec2f43dd502"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25ed6c689c762a5fa345526e66909285"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#a25ed6c689c762a5fa345526e66909285">set_theta</a> (double theta, int i)</td></tr>
<tr class="memdesc:a25ed6c689c762a5fa345526e66909285"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gives theta_ of particle i a specified value.  <br /></td></tr>
<tr class="separator:a25ed6c689c762a5fa345526e66909285"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e06c0e58acfe9fef37b437065b06622"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#a1e06c0e58acfe9fef37b437065b06622">set_w</a> (double w, int i)</td></tr>
<tr class="memdesc:a1e06c0e58acfe9fef37b437065b06622"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gives w_ of particle i a specified value.  <br /></td></tr>
<tr class="separator:a1e06c0e58acfe9fef37b437065b06622"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adefa6aaedd0b7a04c87d660df2c86caf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#adefa6aaedd0b7a04c87d660df2c86caf">set_r</a> (<a class="el" href="classtopology_1_1_vector2d.html">topology::Vector2d</a> r, int i)</td></tr>
<tr class="memdesc:adefa6aaedd0b7a04c87d660df2c86caf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gives r_ of particle i a specified value.  <br /></td></tr>
<tr class="separator:adefa6aaedd0b7a04c87d660df2c86caf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8989ee6be64dcfd8439978741da017ac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#a8989ee6be64dcfd8439978741da017ac">set_rx</a> (double x, int i)</td></tr>
<tr class="memdesc:a8989ee6be64dcfd8439978741da017ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gives x-component of r_ of particle i a specified value.  <br /></td></tr>
<tr class="separator:a8989ee6be64dcfd8439978741da017ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4443ab413d8a0fcd9ca2c52b04089c1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#ae4443ab413d8a0fcd9ca2c52b04089c1">set_ry</a> (double y, int i)</td></tr>
<tr class="memdesc:ae4443ab413d8a0fcd9ca2c52b04089c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gives y-component of r_ of particle i a specified value.  <br /></td></tr>
<tr class="separator:ae4443ab413d8a0fcd9ca2c52b04089c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5441456cc9c95980636aedc16743147e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#a5441456cc9c95980636aedc16743147e">set_p</a> (<a class="el" href="classtopology_1_1_vector2d.html">topology::Vector2d</a> p, int i)</td></tr>
<tr class="memdesc:a5441456cc9c95980636aedc16743147e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gives p_ of particle i a specified value.  <br /></td></tr>
<tr class="separator:a5441456cc9c95980636aedc16743147e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affd5de6e37800528eb15b3a842ebff48"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#affd5de6e37800528eb15b3a842ebff48">set_px</a> (double px, int i)</td></tr>
<tr class="memdesc:affd5de6e37800528eb15b3a842ebff48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gives x-component of p_ of particle i a specified value.  <br /></td></tr>
<tr class="separator:affd5de6e37800528eb15b3a842ebff48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a249e0347dea0c41c4ef85fbd3b8002fd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#a249e0347dea0c41c4ef85fbd3b8002fd">set_py</a> (double py, int i)</td></tr>
<tr class="memdesc:a249e0347dea0c41c4ef85fbd3b8002fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gives y-component of p_ of particle i a specified value.  <br /></td></tr>
<tr class="separator:a249e0347dea0c41c4ef85fbd3b8002fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d77c81ca4c869328301d258a2f2db97"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#a0d77c81ca4c869328301d258a2f2db97">set_particle</a> (double theta, double w, <a class="el" href="classtopology_1_1_vector2d.html">topology::Vector2d</a> r, <a class="el" href="classtopology_1_1_vector2d.html">topology::Vector2d</a> p, int i)</td></tr>
<tr class="memdesc:a0d77c81ca4c869328301d258a2f2db97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets all values theta_, w_, r_, p_ of particle i to the designated values.  <br /></td></tr>
<tr class="separator:a0d77c81ca4c869328301d258a2f2db97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af36d997bcec7a468eb5077cbcf447562"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#af36d997bcec7a468eb5077cbcf447562">set_all_w</a> (double w)</td></tr>
<tr class="memdesc:af36d997bcec7a468eb5077cbcf447562"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets all w to given value (useful for setting T = 0)  <br /></td></tr>
<tr class="separator:af36d997bcec7a468eb5077cbcf447562"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add61103bd8a398fe988671e776cc65d3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#add61103bd8a398fe988671e776cc65d3">set_all_p</a> (<a class="el" href="classtopology_1_1_vector2d.html">topology::Vector2d</a> p)</td></tr>
<tr class="memdesc:add61103bd8a398fe988671e776cc65d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets all p to given value (useful for setting T = 0)  <br /></td></tr>
<tr class="separator:add61103bd8a398fe988671e776cc65d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb305b904e93b3324b722955eaf3f0ab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#afb305b904e93b3324b722955eaf3f0ab">set_all_theta</a> (double theta)</td></tr>
<tr class="memdesc:afb305b904e93b3324b722955eaf3f0ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets all theta to given value (useful for perfect spin alignment)  <br /></td></tr>
<tr class="separator:afb305b904e93b3324b722955eaf3f0ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abccd24c6d129a82f51cab1efd36985dc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#abccd24c6d129a82f51cab1efd36985dc">set_temperature</a> (double kT, int i)</td></tr>
<tr class="memdesc:abccd24c6d129a82f51cab1efd36985dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Randomizes momenta to be in agreement with given kT of particle i.  <br /></td></tr>
<tr class="separator:abccd24c6d129a82f51cab1efd36985dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e7b63db9ca781f493bc0f75007b2955"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#a9e7b63db9ca781f493bc0f75007b2955">set_temperature</a> (double kT)</td></tr>
<tr class="memdesc:a9e7b63db9ca781f493bc0f75007b2955"><td class="mdescLeft">&#160;</td><td class="mdescRight">Randomizes momenta to be in agreement with given kT of all particles.  <br /></td></tr>
<tr class="separator:a9e7b63db9ca781f493bc0f75007b2955"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8495317d9d70b03975790d3fa24175c1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#a8495317d9d70b03975790d3fa24175c1">set_temperature_p</a> (double kT, int i)</td></tr>
<tr class="memdesc:a8495317d9d70b03975790d3fa24175c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Randomizes linear momenta to be in agreement with given kT of particle i.  <br /></td></tr>
<tr class="separator:a8495317d9d70b03975790d3fa24175c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa992e216fef852d4a4584435cc7975cd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#aa992e216fef852d4a4584435cc7975cd">set_temperature_p</a> (double kT)</td></tr>
<tr class="memdesc:aa992e216fef852d4a4584435cc7975cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Randomizes linear momenta to be in agreement with given kT of all particles.  <br /></td></tr>
<tr class="separator:aa992e216fef852d4a4584435cc7975cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f055b391a13687261ebe5d217acecc6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#a7f055b391a13687261ebe5d217acecc6">set_temperature_w</a> (double kT, int i)</td></tr>
<tr class="memdesc:a7f055b391a13687261ebe5d217acecc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Randomizes spin momenta to be in agreement with given kT of particle i.  <br /></td></tr>
<tr class="separator:a7f055b391a13687261ebe5d217acecc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafbf69c4c846604b010bd8558e656624"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#aafbf69c4c846604b010bd8558e656624">set_temperature_w</a> (double kT)</td></tr>
<tr class="memdesc:aafbf69c4c846604b010bd8558e656624"><td class="mdescLeft">&#160;</td><td class="mdescRight">Randomizes spin momenta to be in agreement with given kT of all particles.  <br /></td></tr>
<tr class="separator:aafbf69c4c846604b010bd8558e656624"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92f337867f35fa669ef32e0f19f9dcae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#a92f337867f35fa669ef32e0f19f9dcae">scale_mom</a> (double a)</td></tr>
<tr class="memdesc:a92f337867f35fa669ef32e0f19f9dcae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scales all momenta (w_, p_) by a factor a.  <br /></td></tr>
<tr class="separator:a92f337867f35fa669ef32e0f19f9dcae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1adc9e9f819e6d3c5b42c66c8f039b09"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#a1adc9e9f819e6d3c5b42c66c8f039b09">add_to_theta</a> (const std::vector&lt; double &gt; &amp;theta, double factor=1)</td></tr>
<tr class="memdesc:a1adc9e9f819e6d3c5b42c66c8f039b09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds vector of theta to theta_, scales by factor. Vector must have length of at least N_. Vector of doubles.  <br /></td></tr>
<tr class="separator:a1adc9e9f819e6d3c5b42c66c8f039b09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1a55666191d6773ef379565e9d3af3d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#aa1a55666191d6773ef379565e9d3af3d">add_to_r</a> (const std::vector&lt; <a class="el" href="classtopology_1_1_vector2d.html">topology::Vector2d</a> &gt; &amp;r, double factor=1)</td></tr>
<tr class="memdesc:aa1a55666191d6773ef379565e9d3af3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds vector of r to r_, scales by factor. Vector must have length of at least 2 * N_. Vector of doubles.  <br /></td></tr>
<tr class="separator:aa1a55666191d6773ef379565e9d3af3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a326a53a4ffa5f276ff24138f5e31b23f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#a326a53a4ffa5f276ff24138f5e31b23f">add_to_r</a> (const std::vector&lt; double &gt; &amp;r, double factor=1)</td></tr>
<tr class="memdesc:a326a53a4ffa5f276ff24138f5e31b23f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds vector of r to r_, scales by factor. Vector must have length of at least N_. Vecot of <a class="el" href="classtopology_1_1_vector2d.html" title="Mathematical 2d vectors. Can be added, multiplied by a scalar, norm computation is possible....">topology::Vector2d</a>.  <br /></td></tr>
<tr class="separator:a326a53a4ffa5f276ff24138f5e31b23f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dc6a672cd4ece35b5f640ec2ea8d608"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#a9dc6a672cd4ece35b5f640ec2ea8d608">add_to_coord</a> (const std::vector&lt; double &gt; &amp;coord, double factor=1)</td></tr>
<tr class="memdesc:a9dc6a672cd4ece35b5f640ec2ea8d608"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds vector of coord to all coordinates (r and theta, if available). Vector must have length of at least N_. Vector of doubles. Does nothing for Vicsek type models.  <br /></td></tr>
<tr class="separator:a9dc6a672cd4ece35b5f640ec2ea8d608"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eccd34052a84901037bd3a3bc6c6b48"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#a5eccd34052a84901037bd3a3bc6c6b48">add_to_coord_inertialscaling</a> (const std::vector&lt; double &gt; &amp;coord, double factor=1)</td></tr>
<tr class="memdesc:a5eccd34052a84901037bd3a3bc6c6b48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds vector of coord to all coordinates (r and theta, if available). Scales by factor and inverse intertia (1/m or 1/I, respectively). Vector must have length of at least N_. Vector of doubles. Does nothing for Vicsek type models.  <br /></td></tr>
<tr class="separator:a5eccd34052a84901037bd3a3bc6c6b48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af224e8ccdd5cb0270cffb74e5d29d1eb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#af224e8ccdd5cb0270cffb74e5d29d1eb">add_to_w</a> (const std::vector&lt; double &gt; &amp;w, double factor=1)</td></tr>
<tr class="memdesc:af224e8ccdd5cb0270cffb74e5d29d1eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds vector of w to w_, scales by factor. Vector must have length of at least N_. Vector of doubles.  <br /></td></tr>
<tr class="separator:af224e8ccdd5cb0270cffb74e5d29d1eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c02d72519fadd3bd3426206e40502f4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#a4c02d72519fadd3bd3426206e40502f4">add_to_p</a> (const std::vector&lt; <a class="el" href="classtopology_1_1_vector2d.html">topology::Vector2d</a> &gt; &amp;p, double factor=1)</td></tr>
<tr class="memdesc:a4c02d72519fadd3bd3426206e40502f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds vector of p to p_, scales by factor. Vector must have length of at least N_. Vector of doubles.  <br /></td></tr>
<tr class="separator:a4c02d72519fadd3bd3426206e40502f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a865745e8a8e7a22b9553041eeba04738"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#a865745e8a8e7a22b9553041eeba04738">add_to_p</a> (const std::vector&lt; double &gt; &amp;p, double factor=1)</td></tr>
<tr class="memdesc:a865745e8a8e7a22b9553041eeba04738"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds vector of p to p_, scales by factor. Vector must have length of at least N_. Vector of <a class="el" href="classtopology_1_1_vector2d.html" title="Mathematical 2d vectors. Can be added, multiplied by a scalar, norm computation is possible....">topology::Vector2d</a>.  <br /></td></tr>
<tr class="separator:a865745e8a8e7a22b9553041eeba04738"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a951317bf5136ec8a0b2692550ad8e491"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#a951317bf5136ec8a0b2692550ad8e491">add_to_mom</a> (const std::vector&lt; double &gt; &amp;mom, double factor=1)</td></tr>
<tr class="memdesc:a951317bf5136ec8a0b2692550ad8e491"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds vector of mom to momenta (w and p, if available), scales by factor. Vector must have length of at least N_. Vector of doubles. Does nothing for Vicsek type models.  <br /></td></tr>
<tr class="separator:a951317bf5136ec8a0b2692550ad8e491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4349a3a0eee77c0a54b8d31fab867ea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#ac4349a3a0eee77c0a54b8d31fab867ea">add_random_angle</a> (double angmax)</td></tr>
<tr class="memdesc:ac4349a3a0eee77c0a54b8d31fab867ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a uniformly distributed angle in (-angmax, angmax) to each particle's theta_.  <br /></td></tr>
<tr class="separator:ac4349a3a0eee77c0a54b8d31fab867ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3a441f450ac0f0ffdd385afe8f2b933"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#ab3a441f450ac0f0ffdd385afe8f2b933">add_random_displacement</a> (double rmax)</td></tr>
<tr class="memdesc:ab3a441f450ac0f0ffdd385afe8f2b933"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a uniformly distributed displacement (-rmax, rmax)^2 to each particle's r_.  <br /></td></tr>
<tr class="separator:ab3a441f450ac0f0ffdd385afe8f2b933"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab399b20229d30669f7135bdcf50571d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#ab399b20229d30669f7135bdcf50571d8">stream_along_spin</a> (double v)</td></tr>
<tr class="memdesc:ab399b20229d30669f7135bdcf50571d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Streams along spin, r_new = r + v * spin(theta)  <br /></td></tr>
<tr class="separator:ab399b20229d30669f7135bdcf50571d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3fad0714000a544b77925ea7df44bbc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#af3fad0714000a544b77925ea7df44bbc">set_theta_to_interval</a> ()</td></tr>
<tr class="memdesc:af3fad0714000a544b77925ea7df44bbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets theta_ values to interval (-pi, pi)  <br /></td></tr>
<tr class="separator:af3fad0714000a544b77925ea7df44bbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae522a68e6bef63d88b00676da526d0d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#ae522a68e6bef63d88b00676da526d0d8">set_r_to_pbc</a> ()</td></tr>
<tr class="memdesc:ae522a68e6bef63d88b00676da526d0d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets particle positions according to boundary conditions.  <br /></td></tr>
<tr class="separator:ae522a68e6bef63d88b00676da526d0d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49290bb9d0172ccc094c7bd2c0809db1"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#a49290bb9d0172ccc094c7bd2c0809db1">sum_w</a> () const</td></tr>
<tr class="memdesc:a49290bb9d0172ccc094c7bd2c0809db1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns sum over omega, basically N_&lt;w&gt;. Extensive.  <br /></td></tr>
<tr class="separator:a49290bb9d0172ccc094c7bd2c0809db1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af503088a31633fa02d12a5e3747bf741"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#af503088a31633fa02d12a5e3747bf741">sum_w_squared</a> () const</td></tr>
<tr class="memdesc:af503088a31633fa02d12a5e3747bf741"><td class="mdescLeft">&#160;</td><td class="mdescRight">Omega squared, basically N_&lt;w^2&gt;. Proportional to kinetic energy. Extensive.  <br /></td></tr>
<tr class="separator:af503088a31633fa02d12a5e3747bf741"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a046fab9e71ff6a756d1ef405f1e9af0b"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#a046fab9e71ff6a756d1ef405f1e9af0b">sum_w_4</a> () const</td></tr>
<tr class="memdesc:a046fab9e71ff6a756d1ef405f1e9af0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Omega to the fourth power, basically N_&lt;w^4&gt;. Proportional to kinetic energy. Extensive.  <br /></td></tr>
<tr class="separator:a046fab9e71ff6a756d1ef405f1e9af0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51c3c0f31c8529456ae27f19a8572ec2"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#a51c3c0f31c8529456ae27f19a8572ec2">sum_theta</a> () const</td></tr>
<tr class="memdesc:a51c3c0f31c8529456ae27f19a8572ec2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns sum over all theta, basically N_&lt;theta&gt;. Extensive. Probably pointless.  <br /></td></tr>
<tr class="separator:a51c3c0f31c8529456ae27f19a8572ec2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19d9795ec171a048475c9d5770bc4a50"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtopology_1_1_vector2d.html">topology::Vector2d</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#a19d9795ec171a048475c9d5770bc4a50">sum_s</a> () const</td></tr>
<tr class="memdesc:a19d9795ec171a048475c9d5770bc4a50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Magnetization. Basically N_&lt;s&gt;. Extensive.  <br /></td></tr>
<tr class="separator:a19d9795ec171a048475c9d5770bc4a50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c5591c152957f544ca88f3d728dd408"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#a2c5591c152957f544ca88f3d728dd408">sum_s_squared</a> () const</td></tr>
<tr class="memdesc:a2c5591c152957f544ca88f3d728dd408"><td class="mdescLeft">&#160;</td><td class="mdescRight">Magnetization squared. Basically N_&lt;s&gt;^2. Extensive.  <br /></td></tr>
<tr class="separator:a2c5591c152957f544ca88f3d728dd408"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a224b157d47ccae2095d7599e94fee0cf"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#a224b157d47ccae2095d7599e94fee0cf">sum_s_4</a> () const</td></tr>
<tr class="memdesc:a224b157d47ccae2095d7599e94fee0cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Magnetization to the fourth power. Basically N_&lt;s&gt;^4. Extensive.  <br /></td></tr>
<tr class="separator:a224b157d47ccae2095d7599e94fee0cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab1c1c3b62fc05dceb53e0c445c17d1c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtopology_1_1_vector2d.html">topology::Vector2d</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#aab1c1c3b62fc05dceb53e0c445c17d1c">sum_p</a> () const</td></tr>
<tr class="memdesc:aab1c1c3b62fc05dceb53e0c445c17d1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total momentum. Basically N_&lt;p&gt;. Extensive.  <br /></td></tr>
<tr class="separator:aab1c1c3b62fc05dceb53e0c445c17d1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad244abed9cd7f87eaf339dd05e1343a"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#aad244abed9cd7f87eaf339dd05e1343a">sum_p_squared</a> () const</td></tr>
<tr class="memdesc:aad244abed9cd7f87eaf339dd05e1343a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sum over momentum squared. Basically N_&lt;p^2&gt;. Extensive.  <br /></td></tr>
<tr class="separator:aad244abed9cd7f87eaf339dd05e1343a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8c5249e354de1d6388d3c3a2b92890c"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#ae8c5249e354de1d6388d3c3a2b92890c">sum_p_4</a> () const</td></tr>
<tr class="memdesc:ae8c5249e354de1d6388d3c3a2b92890c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sum over momentum to the fourth power. Basically N_&lt;p^4&gt;. Extensive.  <br /></td></tr>
<tr class="separator:ae8c5249e354de1d6388d3c3a2b92890c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b7c50f6a58e005e4224b06bdd3866bf"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#a4b7c50f6a58e005e4224b06bdd3866bf">sum_e_squared</a> () const</td></tr>
<tr class="memdesc:a4b7c50f6a58e005e4224b06bdd3866bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total energy squared, basically N_&lt;e_i^2&gt;. Extensive.  <br /></td></tr>
<tr class="separator:a4b7c50f6a58e005e4224b06bdd3866bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a503ead15968b11cd41ff36e0b2873d0f"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#a503ead15968b11cd41ff36e0b2873d0f">sum_ekin_squared</a> () const</td></tr>
<tr class="memdesc:a503ead15968b11cd41ff36e0b2873d0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kinetic energy squared, basically N_&lt;e_{i,kin}^2&gt;. Extensive.  <br /></td></tr>
<tr class="separator:a503ead15968b11cd41ff36e0b2873d0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0385b0d7559127fbfdc5b28b0ee18f1c"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#a0385b0d7559127fbfdc5b28b0ee18f1c">sum_eint_squared</a> () const</td></tr>
<tr class="memdesc:a0385b0d7559127fbfdc5b28b0ee18f1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interaction energy squared, basically N_&lt;e_{i,int}^2&gt;. Extensive.  <br /></td></tr>
<tr class="separator:a0385b0d7559127fbfdc5b28b0ee18f1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3114842264203a2c14c1c16feea2d417"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#a3114842264203a2c14c1c16feea2d417">binder_cumulant</a> () const</td></tr>
<tr class="memdesc:a3114842264203a2c14c1c16feea2d417"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binder cumulant. 1 - &lt;s^4&gt; / (3 &lt;s^2&gt;). Intensive.  <br /></td></tr>
<tr class="separator:a3114842264203a2c14c1c16feea2d417"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a4be7da7f0f4e32ee66d64f05639ada"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#a3a4be7da7f0f4e32ee66d64f05639ada">calc_interaction_energy</a> () const</td></tr>
<tr class="memdesc:a3a4be7da7f0f4e32ee66d64f05639ada"><td class="mdescLeft">&#160;</td><td class="mdescRight">System interaction energy. Extensive.  <br /></td></tr>
<tr class="separator:a3a4be7da7f0f4e32ee66d64f05639ada"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa19ffd58dbb8f5ec1e99b1dd5087adf0"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#aa19ffd58dbb8f5ec1e99b1dd5087adf0">calc_interaction_energy</a> (int i) const</td></tr>
<tr class="memdesc:aa19ffd58dbb8f5ec1e99b1dd5087adf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interaction energy of particle i.  <br /></td></tr>
<tr class="separator:aa19ffd58dbb8f5ec1e99b1dd5087adf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93b89d7f402d699ae1fbaeca09b894f1"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#a93b89d7f402d699ae1fbaeca09b894f1">calc_kinetic_energy</a> () const</td></tr>
<tr class="memdesc:a93b89d7f402d699ae1fbaeca09b894f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns system energy. Extensive.  <br /></td></tr>
<tr class="separator:a93b89d7f402d699ae1fbaeca09b894f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c536814249a31417d693d92563d5bf2"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#a7c536814249a31417d693d92563d5bf2">calc_kinetic_energy</a> (int i) const</td></tr>
<tr class="memdesc:a7c536814249a31417d693d92563d5bf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns kinetic energy of particle i.  <br /></td></tr>
<tr class="separator:a7c536814249a31417d693d92563d5bf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade654ed5c479fa2f7637c41dc12d6f15"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#ade654ed5c479fa2f7637c41dc12d6f15">calc_energy</a> () const</td></tr>
<tr class="memdesc:ade654ed5c479fa2f7637c41dc12d6f15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns system energy. Extensive.  <br /></td></tr>
<tr class="separator:ade654ed5c479fa2f7637c41dc12d6f15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee18071ecd1eaa245ac097382f89b0b8"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#aee18071ecd1eaa245ac097382f89b0b8">calc_energy</a> (int i) const</td></tr>
<tr class="memdesc:aee18071ecd1eaa245ac097382f89b0b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Energy of particle i. Extensive.  <br /></td></tr>
<tr class="separator:aee18071ecd1eaa245ac097382f89b0b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7f8951239c09090c26639828494a93b"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#ab7f8951239c09090c26639828494a93b">calc_temperature</a> () const</td></tr>
<tr class="memdesc:ab7f8951239c09090c26639828494a93b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns temperature. Careful, this function returns ((&lt;p^2&gt;-.  <br /></td></tr>
<tr class="separator:ab7f8951239c09090c26639828494a93b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d75ec867ad5dd9086b0a76a274150c8"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#a6d75ec867ad5dd9086b0a76a274150c8">calc_temperature_w</a> () const</td></tr>
<tr class="memdesc:a6d75ec867ad5dd9086b0a76a274150c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns spin angular momentum temperature.  <br /></td></tr>
<tr class="separator:a6d75ec867ad5dd9086b0a76a274150c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03fdfcbbf43dcd0313997740b879c2b5"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#a03fdfcbbf43dcd0313997740b879c2b5">calc_temperature_p</a> () const</td></tr>
<tr class="memdesc:a03fdfcbbf43dcd0313997740b879c2b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns linear momentum temperature.  <br /></td></tr>
<tr class="separator:a03fdfcbbf43dcd0313997740b879c2b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ac60bdc2adb8efbfae4753fa2b94e1d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#a0ac60bdc2adb8efbfae4753fa2b94e1d">plaquette</a> (int i) const</td></tr>
<tr class="memdesc:a0ac60bdc2adb8efbfae4753fa2b94e1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the plaquette the particle i belongs to. i is in the lower left corner. Only works for lattice-based models.  <br /></td></tr>
<tr class="separator:a0ac60bdc2adb8efbfae4753fa2b94e1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05568e37fd285c9d3db91e72cbbaf1e5"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#a05568e37fd285c9d3db91e72cbbaf1e5">calc_vorticity</a> (int index) const</td></tr>
<tr class="memdesc:a05568e37fd285c9d3db91e72cbbaf1e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns vorticity along the plaquette at index.  <br /></td></tr>
<tr class="separator:a05568e37fd285c9d3db91e72cbbaf1e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cb763408196d3f624462cdd50299160"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#a1cb763408196d3f624462cdd50299160">calc_vortexdensity_unsigned</a> () const</td></tr>
<tr class="memdesc:a1cb763408196d3f624462cdd50299160"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the unsigned vortex density (i.e. number of vortices divided by box area).  <br /></td></tr>
<tr class="separator:a1cb763408196d3f624462cdd50299160"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44bcc7bf737e4a51f604491546d2000b"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#a44bcc7bf737e4a51f604491546d2000b">calc_vortexdensity_signed</a> () const</td></tr>
<tr class="memdesc:a44bcc7bf737e4a51f604491546d2000b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the signed vortex density (i.e. number of positive vortices minus number of negative vortices divided by box area).  <br /></td></tr>
<tr class="separator:a44bcc7bf737e4a51f604491546d2000b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72a5b9635814dd9c3f13cde050957405"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#a72a5b9635814dd9c3f13cde050957405">calc_space_angular_mom</a> () const</td></tr>
<tr class="memdesc:a72a5b9635814dd9c3f13cde050957405"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns total spatial angular momentum of particles.  <br /></td></tr>
<tr class="separator:a72a5b9635814dd9c3f13cde050957405"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab78f20d5babe58f96031c23dbea95844"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#ab78f20d5babe58f96031c23dbea95844">calc_space_angular_mom</a> (int i) const</td></tr>
<tr class="memdesc:ab78f20d5babe58f96031c23dbea95844"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns spatial angular momentum of the particle with index i.  <br /></td></tr>
<tr class="separator:ab78f20d5babe58f96031c23dbea95844"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7918e895717ed9b4825aa70ad2c9ad15"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#a7918e895717ed9b4825aa70ad2c9ad15">calc_neighbor_mean</a> (double te_pow, double r_pow, double cos_pow, double sin_pow, double J_pow, double Up_pow, double Upp_pow) const</td></tr>
<tr class="memdesc:a7918e895717ed9b4825aa70ad2c9ad15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the mean over nearest neighbors.  <br /></td></tr>
<tr class="separator:a7918e895717ed9b4825aa70ad2c9ad15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72b9e36213857ea0b2cf44752d0ca077"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#a72b9e36213857ea0b2cf44752d0ca077">calc_helicity</a> (double beta) const</td></tr>
<tr class="memdesc:a72b9e36213857ea0b2cf44752d0ca077"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the helicity modulus and auxiliary quantities. Output is a vector with entries (Upsilon,H_x,H_y,I_x,I_y)  <br /></td></tr>
<tr class="separator:a72b9e36213857ea0b2cf44752d0ca077"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a659cc51e831f8d1661c06c9997ca56c6"><td class="memItemLeft" align="right" valign="top">std::complex&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#a659cc51e831f8d1661c06c9997ca56c6">calc_eiqr</a> (const <a class="el" href="classtopology_1_1_vector2d.html">topology::Vector2d</a> q, int i) const</td></tr>
<tr class="memdesc:a659cc51e831f8d1661c06c9997ca56c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates e^(i q r_i) for particle i.  <br /></td></tr>
<tr class="separator:a659cc51e831f8d1661c06c9997ca56c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f857cb3c2706998ae4f19e522297fd9"><td class="memItemLeft" align="right" valign="top">std::complex&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#a4f857cb3c2706998ae4f19e522297fd9">calc_mxq</a> (const <a class="el" href="classtopology_1_1_vector2d.html">topology::Vector2d</a> q, double Mx_0) const</td></tr>
<tr class="memdesc:a4f857cb3c2706998ae4f19e522297fd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates $m_{x,q}$ (see Bissinger PhD thesis) and <a class="el" href="classgroup.html#a82e650581e00e2fa5f4eddde45180fd9">calc_fieldfluct </a>.  <br /></td></tr>
<tr class="separator:a4f857cb3c2706998ae4f19e522297fd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80e571e014722e2aa44fa52e15f2e24e"><td class="memItemLeft" align="right" valign="top">std::complex&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#a80e571e014722e2aa44fa52e15f2e24e">calc_myq</a> (const <a class="el" href="classtopology_1_1_vector2d.html">topology::Vector2d</a> q, double My_0) const</td></tr>
<tr class="memdesc:a80e571e014722e2aa44fa52e15f2e24e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates $m_{y,q}$ (see Bissinger PhD thesis) and <a class="el" href="classgroup.html#a82e650581e00e2fa5f4eddde45180fd9">calc_fieldfluct </a>.  <br /></td></tr>
<tr class="separator:a80e571e014722e2aa44fa52e15f2e24e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbefb8517df13e29f18f97a5576a72a5"><td class="memItemLeft" align="right" valign="top">std::complex&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#adbefb8517df13e29f18f97a5576a72a5">calc_wq</a> (const <a class="el" href="classtopology_1_1_vector2d.html">topology::Vector2d</a> q, double W_0) const</td></tr>
<tr class="memdesc:adbefb8517df13e29f18f97a5576a72a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates $w_{q}$ (see Bissinger PhD thesis) and <a class="el" href="classgroup.html#a82e650581e00e2fa5f4eddde45180fd9">calc_fieldfluct </a>.  <br /></td></tr>
<tr class="separator:adbefb8517df13e29f18f97a5576a72a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a1aacbfee5f6c7c303fd54afa9637c7"><td class="memItemLeft" align="right" valign="top">std::complex&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#a4a1aacbfee5f6c7c303fd54afa9637c7">calc_eq</a> (const <a class="el" href="classtopology_1_1_vector2d.html">topology::Vector2d</a> q, double E_0) const</td></tr>
<tr class="memdesc:a4a1aacbfee5f6c7c303fd54afa9637c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates $e_{q}$ (see Bissinger PhD thesis) and <a class="el" href="classgroup.html#a82e650581e00e2fa5f4eddde45180fd9">calc_fieldfluct </a>.  <br /></td></tr>
<tr class="separator:a4a1aacbfee5f6c7c303fd54afa9637c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6bdf3edcf8676059bc5fb0b2d761ce0"><td class="memItemLeft" align="right" valign="top">std::complex&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#ac6bdf3edcf8676059bc5fb0b2d761ce0">calc_teq</a> (const <a class="el" href="classtopology_1_1_vector2d.html">topology::Vector2d</a> q, double Te_0) const</td></tr>
<tr class="memdesc:ac6bdf3edcf8676059bc5fb0b2d761ce0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates $theta_{q}$ (see Bissinger PhD thesis) and <a class="el" href="classgroup.html#a82e650581e00e2fa5f4eddde45180fd9">calc_fieldfluct </a>.  <br /></td></tr>
<tr class="separator:ac6bdf3edcf8676059bc5fb0b2d761ce0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1789f66f507ed05dbc84b1f3331a4be"><td class="memItemLeft" align="right" valign="top">std::complex&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#ae1789f66f507ed05dbc84b1f3331a4be">calc_rq</a> (const <a class="el" href="classtopology_1_1_vector2d.html">topology::Vector2d</a> q) const</td></tr>
<tr class="memdesc:ae1789f66f507ed05dbc84b1f3331a4be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates $rho_{q}$ (see Bissinger PhD thesis) and <a class="el" href="classgroup.html#a82e650581e00e2fa5f4eddde45180fd9">calc_fieldfluct </a>.  <br /></td></tr>
<tr class="separator:ae1789f66f507ed05dbc84b1f3331a4be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a570ebbe5db9eb12267985d724b7b9b22"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::complex&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#a570ebbe5db9eb12267985d724b7b9b22">calc_jq</a> (const <a class="el" href="classtopology_1_1_vector2d.html">topology::Vector2d</a> q, <a class="el" href="classtopology_1_1_vector2d.html">topology::Vector2d</a> J_0) const</td></tr>
<tr class="memdesc:a570ebbe5db9eb12267985d724b7b9b22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates $j_{q}$ (see Bissinger PhD thesis) and <a class="el" href="classgroup.html#a82e650581e00e2fa5f4eddde45180fd9">calc_fieldfluct </a>.  <br /></td></tr>
<tr class="separator:a570ebbe5db9eb12267985d724b7b9b22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac17cd8d0b2c4ffac7e6a5c1027bfcc95"><td class="memItemLeft" align="right" valign="top">std::complex&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#ac17cd8d0b2c4ffac7e6a5c1027bfcc95">calc_jqpar</a> (const <a class="el" href="classtopology_1_1_vector2d.html">topology::Vector2d</a> q, <a class="el" href="classtopology_1_1_vector2d.html">topology::Vector2d</a> J_0) const</td></tr>
<tr class="memdesc:ac17cd8d0b2c4ffac7e6a5c1027bfcc95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates $j_{q,L}$ (see Bissinger PhD thesis) and <a class="el" href="classgroup.html#a82e650581e00e2fa5f4eddde45180fd9">calc_fieldfluct </a>.  <br /></td></tr>
<tr class="separator:ac17cd8d0b2c4ffac7e6a5c1027bfcc95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd3874e3abc2733663ceb07f2c1dd465"><td class="memItemLeft" align="right" valign="top">std::complex&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#afd3874e3abc2733663ceb07f2c1dd465">calc_jqperp</a> (const <a class="el" href="classtopology_1_1_vector2d.html">topology::Vector2d</a> q, <a class="el" href="classtopology_1_1_vector2d.html">topology::Vector2d</a> J_0) const</td></tr>
<tr class="memdesc:afd3874e3abc2733663ceb07f2c1dd465"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates $j_{q,T}$ (see Bissinger PhD thesis) and <a class="el" href="classgroup.html#a82e650581e00e2fa5f4eddde45180fd9">calc_fieldfluct </a>.  <br /></td></tr>
<tr class="separator:afd3874e3abc2733663ceb07f2c1dd465"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9478386c54ff4f2528fef370390fd5db"><td class="memItemLeft" align="right" valign="top">std::complex&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#a9478386c54ff4f2528fef370390fd5db">calc_lq</a> (const <a class="el" href="classtopology_1_1_vector2d.html">topology::Vector2d</a> q, double L_0) const</td></tr>
<tr class="memdesc:a9478386c54ff4f2528fef370390fd5db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates $l_{q}$ (see Bissinger PhD thesis) and <a class="el" href="classgroup.html#a82e650581e00e2fa5f4eddde45180fd9">calc_fieldfluct </a>.  <br /></td></tr>
<tr class="separator:a9478386c54ff4f2528fef370390fd5db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac815d41c4492553f0748846df521f5da"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#ac815d41c4492553f0748846df521f5da">calc_fieldfluct_average</a> (std::string fluctname, <a class="el" href="classtopology_1_1_vector2d.html">topology::Vector2d</a> q=0) const</td></tr>
<tr class="memdesc:ac815d41c4492553f0748846df521f5da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the average of the field fluctuation fluctname. (e.g. for "wq" this returns sum omega_i.)  <br /></td></tr>
<tr class="separator:ac815d41c4492553f0748846df521f5da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3073bfec2b6adb914cf5f26e5c0de32"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#ac3073bfec2b6adb914cf5f26e5c0de32">calc_one_particle_density</a> (int index, std::string fluctname, <a class="el" href="classtopology_1_1_vector2d.html">topology::Vector2d</a> q=0) const</td></tr>
<tr class="memdesc:ac3073bfec2b6adb914cf5f26e5c0de32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the one-particle density associated with the field fluctuation fluctname. (e.g. for "wq" this returns omega_index.)  <br /></td></tr>
<tr class="separator:ac3073bfec2b6adb914cf5f26e5c0de32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82e650581e00e2fa5f4eddde45180fd9"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::complex&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#a82e650581e00e2fa5f4eddde45180fd9">calc_fieldfluct</a> (const std::vector&lt; <a class="el" href="classtopology_1_1_vector2d.html">topology::Vector2d</a> &gt; qvals, std::string fluctname) const</td></tr>
<tr class="memdesc:a82e650581e00e2fa5f4eddde45180fd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the field fluctuation for the quantity specified in fluctname.  <br /></td></tr>
<tr class="separator:a82e650581e00e2fa5f4eddde45180fd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b13aa6835031fc76780148ab9cc4434"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::complex&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#a3b13aa6835031fc76780148ab9cc4434">calc_fieldfluct_convolution</a> (const std::vector&lt; <a class="el" href="classtopology_1_1_vector2d.html">topology::Vector2d</a> &gt; qvals, std::string fluctname_1, std::string fluctname_2) const</td></tr>
<tr class="memdesc:a3b13aa6835031fc76780148ab9cc4434"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the field fluctuation for the quantity specified in fluctname.  <br /></td></tr>
<tr class="separator:a3b13aa6835031fc76780148ab9cc4434"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a683c6fefe6132e6b4685d4099c23b3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtopology_1_1_vector2d.html">topology::Vector2d</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#a0a683c6fefe6132e6b4685d4099c23b3">calc_tau</a> () const</td></tr>
<tr class="memdesc:a0a683c6fefe6132e6b4685d4099c23b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates \(\tau\), as defined for the xy model. NOT CORRECT FOR THE MOBILE CASE.  <br /></td></tr>
<tr class="separator:a0a683c6fefe6132e6b4685d4099c23b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f819a6f9ebdb8d49f7f77c659fbc94d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtopology_1_1_vector2d.html">topology::Vector2d</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#a2f819a6f9ebdb8d49f7f77c659fbc94d">calc_je</a> () const</td></tr>
<tr class="memdesc:a2f819a6f9ebdb8d49f7f77c659fbc94d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates \(j^e\), as defined for the xy model. NOT CORRECT FOR THE MOBILE CASE.  <br /></td></tr>
<tr class="separator:a2f819a6f9ebdb8d49f7f77c659fbc94d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a542808253fe680dd21ed20716d90bfc3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtopology_1_1_vector2d.html">topology::Vector2d</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#a542808253fe680dd21ed20716d90bfc3">calc_current</a> (std::string currentname) const</td></tr>
<tr class="memdesc:a542808253fe680dd21ed20716d90bfc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the current for the quantity specified in currentname. currentname = {"tau","je"}. NOT CORRECT FOR THE MOBILE CASE.  <br /></td></tr>
<tr class="separator:a542808253fe680dd21ed20716d90bfc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adceefccfc1a29c7428974ebce0f9ecef"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#adceefccfc1a29c7428974ebce0f9ecef">calc_SCF_S_individual</a> (const int index, const std::vector&lt; double &gt; rbin, std::vector&lt; int &gt; &amp;counts) const</td></tr>
<tr class="memdesc:adceefccfc1a29c7428974ebce0f9ecef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the static spin correlation function for a specific particle at index.  <br /></td></tr>
<tr class="separator:adceefccfc1a29c7428974ebce0f9ecef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82e24fe33ee6468dfcf7289c71124ef7"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#a82e24fe33ee6468dfcf7289c71124ef7">calc_SCF_S_oriented_individual</a> (const int index, const std::vector&lt; double &gt; rbin, const double &amp;orientation_angle, std::vector&lt; int &gt; &amp;counts) const</td></tr>
<tr class="memdesc:a82e24fe33ee6468dfcf7289c71124ef7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the static oriented spin correlation function for a specific particle at index.  <br /></td></tr>
<tr class="separator:a82e24fe33ee6468dfcf7289c71124ef7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad19944292752c21dfe3419c15bf3b8f3"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#ad19944292752c21dfe3419c15bf3b8f3">calc_SCF_g_individual</a> (const int index, const std::vector&lt; double &gt; rbin) const</td></tr>
<tr class="memdesc:ad19944292752c21dfe3419c15bf3b8f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the pair distribution function g(r) for a specific particle at index.  <br /></td></tr>
<tr class="separator:ad19944292752c21dfe3419c15bf3b8f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad55bd73ba599cbed393926a61f499a46"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#ad55bd73ba599cbed393926a61f499a46">calc_SCF_g</a> (const std::vector&lt; double &gt; rbin, int number_of_points) const</td></tr>
<tr class="memdesc:ad55bd73ba599cbed393926a61f499a46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the overall pair distribution function g(r)  <br /></td></tr>
<tr class="separator:ad55bd73ba599cbed393926a61f499a46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dacb625fe5f1435cc7e4eeb77dae77f"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#a4dacb625fe5f1435cc7e4eeb77dae77f">calc_SCF_anglediff_individual</a> (const int index, const std::vector&lt; double &gt; rbin, std::vector&lt; int &gt; &amp;counts) const</td></tr>
<tr class="memdesc:a4dacb625fe5f1435cc7e4eeb77dae77f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the static angle difference correlation function for a specific particle at index.  <br /></td></tr>
<tr class="separator:a4dacb625fe5f1435cc7e4eeb77dae77f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadc8981b3862eef09f21febd56042f6a"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#aadc8981b3862eef09f21febd56042f6a">calc_SCF_E_individual</a> (const int index, const std::vector&lt; double &gt; rbin, std::vector&lt; int &gt; &amp;counts) const</td></tr>
<tr class="memdesc:aadc8981b3862eef09f21febd56042f6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the static total energy correlation function for a specific particle at index.  <br /></td></tr>
<tr class="separator:aadc8981b3862eef09f21febd56042f6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96a49b24c17de671412d332e96acf3ba"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#a96a49b24c17de671412d332e96acf3ba">calc_SCF_Ekin_individual</a> (const int index, const std::vector&lt; double &gt; rbin, std::vector&lt; int &gt; &amp;counts) const</td></tr>
<tr class="memdesc:a96a49b24c17de671412d332e96acf3ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the static kinetic energy correlation function for a specific particle at index.  <br /></td></tr>
<tr class="separator:a96a49b24c17de671412d332e96acf3ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e7eff1e7b38c8c9b170422d5f5a158c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#a8e7eff1e7b38c8c9b170422d5f5a158c">calc_SCF_Eint_individual</a> (const int index, const std::vector&lt; double &gt; rbin, std::vector&lt; int &gt; &amp;counts) const</td></tr>
<tr class="memdesc:a8e7eff1e7b38c8c9b170422d5f5a158c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the static interaction energy correlation function for a specific particle at index.  <br /></td></tr>
<tr class="separator:a8e7eff1e7b38c8c9b170422d5f5a158c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91b0fc82c16c8c5dfc77ae079fe577af"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#a91b0fc82c16c8c5dfc77ae079fe577af">calc_SCF_P_individual</a> (const int index, const std::vector&lt; double &gt; rbin, std::vector&lt; int &gt; &amp;counts) const</td></tr>
<tr class="memdesc:a91b0fc82c16c8c5dfc77ae079fe577af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the static momentum correlation function for a specific particle at index.  <br /></td></tr>
<tr class="separator:a91b0fc82c16c8c5dfc77ae079fe577af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae912c98c7c9dd2f937dcf7433052448f"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#ae912c98c7c9dd2f937dcf7433052448f">calc_SCF_W_individual</a> (const int index, const std::vector&lt; double &gt; rbin, std::vector&lt; int &gt; &amp;counts) const</td></tr>
<tr class="memdesc:ae912c98c7c9dd2f937dcf7433052448f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the static spin momentum correlation function for a specific particle at index.  <br /></td></tr>
<tr class="separator:ae912c98c7c9dd2f937dcf7433052448f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa86f4574a2829525d00468c9eb6981a0"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#aa86f4574a2829525d00468c9eb6981a0">calc_SCF_averaged</a> (const std::vector&lt; double &gt; rbin, int number_of_points, const std::string name) const</td></tr>
<tr class="memdesc:aa86f4574a2829525d00468c9eb6981a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the static correlation function specified by name for number_of_points many random particles.  <br /></td></tr>
<tr class="separator:aa86f4574a2829525d00468c9eb6981a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32348ae34fde015c4573e29a9418ea40"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#a32348ae34fde015c4573e29a9418ea40">calc_ACF_S</a> (const <a class="el" href="classgroup.html">group</a> &amp;G_initial) const</td></tr>
<tr class="memdesc:a32348ae34fde015c4573e29a9418ea40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the spin autocorrelation-function averaged over all indices.  <br /></td></tr>
<tr class="separator:a32348ae34fde015c4573e29a9418ea40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e65f260fd3890a6da740e95be012103"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#a8e65f260fd3890a6da740e95be012103">calc_ACF_anglediff</a> (const <a class="el" href="classgroup.html">group</a> &amp;G_initial) const</td></tr>
<tr class="memdesc:a8e65f260fd3890a6da740e95be012103"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the angle difference autocorrelation-function averaged over all indices.  <br /></td></tr>
<tr class="separator:a8e65f260fd3890a6da740e95be012103"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2713c59d11edc237520da530ea6aab13"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#a2713c59d11edc237520da530ea6aab13">calc_ACF_sp</a> (const <a class="el" href="classgroup.html">group</a> &amp;G_initial, const std::string name) const</td></tr>
<tr class="memdesc:a2713c59d11edc237520da530ea6aab13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the single-particle autocorrelation-function for some quantity specified by name.  <br /></td></tr>
<tr class="separator:a2713c59d11edc237520da530ea6aab13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89bd90c457c1675a5365dcd7351798dd"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#a89bd90c457c1675a5365dcd7351798dd">calc_ACF_q0</a> (const <a class="el" href="classgroup.html">group</a> &amp;G_initial, const std::string name) const</td></tr>
<tr class="memdesc:a89bd90c457c1675a5365dcd7351798dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the (q=0)-autocorrelation-function for some quantity specified by name.  <br /></td></tr>
<tr class="separator:a89bd90c457c1675a5365dcd7351798dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6edf3a06534225562427fab80486a83"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::complex&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#af6edf3a06534225562427fab80486a83">calc_TCF</a> (const <a class="el" href="classgroup.html">group</a> &amp;G_initial, std::vector&lt; <a class="el" href="classtopology_1_1_vector2d.html">topology::Vector2d</a> &gt; qvals, std::string fluctname_initial, std::string fluctname_current) const</td></tr>
<tr class="memdesc:af6edf3a06534225562427fab80486a83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates time-correlation function between two different groups. Fluctuation names must be specified.  <br /></td></tr>
<tr class="separator:af6edf3a06534225562427fab80486a83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a737b1562e521a90ceb6dd9630162a01d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#a737b1562e521a90ceb6dd9630162a01d">time_derivative_theta</a> () const</td></tr>
<tr class="memdesc:a737b1562e521a90ceb6dd9630162a01d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns theta (spin angle) time derivative (splitting useful for leapfrog)  <br /></td></tr>
<tr class="separator:a737b1562e521a90ceb6dd9630162a01d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a982bd50ec79efd6e0d8a687b302e356e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#a982bd50ec79efd6e0d8a687b302e356e">time_derivative_w</a> () const</td></tr>
<tr class="memdesc:a982bd50ec79efd6e0d8a687b302e356e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns omega (spin momentum) time derivative (splitting useful for leapfrog)  <br /></td></tr>
<tr class="separator:a982bd50ec79efd6e0d8a687b302e356e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9df3ca3f2cf67926b44db61a5218af0"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#ad9df3ca3f2cf67926b44db61a5218af0">time_derivative_r</a> () const</td></tr>
<tr class="memdesc:ad9df3ca3f2cf67926b44db61a5218af0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns r (particle position) time derivative. First N_ entries are x direction, N_+1 to 2N_ is y direction (splitting useful for leapfrog)  <br /></td></tr>
<tr class="separator:ad9df3ca3f2cf67926b44db61a5218af0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a400e7b2bf08f4480fb9a047003f2541e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#a400e7b2bf08f4480fb9a047003f2541e">time_derivative_p</a> () const</td></tr>
<tr class="memdesc:a400e7b2bf08f4480fb9a047003f2541e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns p (linear momentum) time derivative. First N_ entries are x direction, N_+1 to 2N_ is y direction (splitting useful for leapfrog)  <br /></td></tr>
<tr class="separator:a400e7b2bf08f4480fb9a047003f2541e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a879ba3c38c405b39cdf3a404518019d5"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#a879ba3c38c405b39cdf3a404518019d5">time_derivative_coord</a> () const</td></tr>
<tr class="memdesc:a879ba3c38c405b39cdf3a404518019d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns coordinate time derivative (first N_ entries are theta, then r_x, then r_y).  <br /></td></tr>
<tr class="separator:a879ba3c38c405b39cdf3a404518019d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33234f8ffb4027528c50dedac6bec20a"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#a33234f8ffb4027528c50dedac6bec20a">time_derivative_mom</a> () const</td></tr>
<tr class="memdesc:a33234f8ffb4027528c50dedac6bec20a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns momenta time derivative (first N_ entries are omega, then p_x, then p_y).  <br /></td></tr>
<tr class="separator:a33234f8ffb4027528c50dedac6bec20a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9696e88dfbee235e456180afa2a73e14"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgroup.html">group</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#a9696e88dfbee235e456180afa2a73e14">time_derivative</a> () const</td></tr>
<tr class="memdesc:a9696e88dfbee235e456180afa2a73e14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns time derivative of the entire group.  <br /></td></tr>
<tr class="separator:a9696e88dfbee235e456180afa2a73e14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a316a74bbcdad5160b6a106d869a9d84d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#a316a74bbcdad5160b6a106d869a9d84d">coord_diff</a> (const <a class="el" href="classgroup.html">group</a> &amp;G) const</td></tr>
<tr class="memdesc:a316a74bbcdad5160b6a106d869a9d84d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns coordinate difference between this group and another one, with proper care of boundaries. First N_ entries are theta, then r_x, then r_y.  <br /></td></tr>
<tr class="separator:a316a74bbcdad5160b6a106d869a9d84d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28fc1d3cc5bb465208b95e965ae2c45d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#a28fc1d3cc5bb465208b95e965ae2c45d">accumulative_MSD</a> (std::vector&lt; double &gt; &amp;MSD, const <a class="el" href="classgroup.html">group</a> &amp;last_G) const</td></tr>
<tr class="memdesc:a28fc1d3cc5bb465208b95e965ae2c45d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as coord_diff, but adding the difference to an MSD vector.  <br /></td></tr>
<tr class="separator:a28fc1d3cc5bb465208b95e965ae2c45d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dda93b15acd8592e527157f461b2d17"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgroup.html">group</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#a2dda93b15acd8592e527157f461b2d17">operator+=</a> (const <a class="el" href="classgroup.html">group</a> &amp;G)</td></tr>
<tr class="memdesc:a2dda93b15acd8592e527157f461b2d17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds particle entries (used for adding time derivatives and such).  <br /></td></tr>
<tr class="separator:a2dda93b15acd8592e527157f461b2d17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adac1e7cbd401a8e1cb89aec29d022909"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgroup.html">group</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#adac1e7cbd401a8e1cb89aec29d022909">operator*=</a> (const double a)</td></tr>
<tr class="memdesc:adac1e7cbd401a8e1cb89aec29d022909"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies particles by constant (used for adding time derivatives and such).  <br /></td></tr>
<tr class="separator:adac1e7cbd401a8e1cb89aec29d022909"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:abba72880d78720291cdd5267f96cebbf"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#abba72880d78720291cdd5267f96cebbf">group_type_</a></td></tr>
<tr class="memdesc:abba72880d78720291cdd5267f96cebbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the group. Can be "xy" for the XY model, "mxy" for the mobile XY model, "fmxy" for a mobile XY model frozen in place, "vm" for the Vicsek model and "fvm" for the frozen (static) Vicsek model.  <br /></td></tr>
<tr class="separator:abba72880d78720291cdd5267f96cebbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0902e9bfec3a71e48d68db8f367d2228"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#a0902e9bfec3a71e48d68db8f367d2228">N_</a></td></tr>
<tr class="memdesc:a0902e9bfec3a71e48d68db8f367d2228"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of the group.  <br /></td></tr>
<tr class="separator:a0902e9bfec3a71e48d68db8f367d2228"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5664d0f4bbf27f9f8cad68d333691e8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#ad5664d0f4bbf27f9f8cad68d333691e8">sqrtN_</a></td></tr>
<tr class="memdesc:ad5664d0f4bbf27f9f8cad68d333691e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Square root of the group size (often useful).  <br /></td></tr>
<tr class="separator:ad5664d0f4bbf27f9f8cad68d333691e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fd5c592e393b150d715cf06cdcc3373"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtopology_1_1_vector2d.html">topology::Vector2d</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#a1fd5c592e393b150d715cf06cdcc3373">L_</a></td></tr>
<tr class="memdesc:a1fd5c592e393b150d715cf06cdcc3373"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of the box (some functions only defined for square boxes yet).  <br /></td></tr>
<tr class="separator:a1fd5c592e393b150d715cf06cdcc3373"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e224ee273f6971cf0a76756c6c583f1"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#a5e224ee273f6971cf0a76756c6c583f1">I_</a> = 1</td></tr>
<tr class="memdesc:a5e224ee273f6971cf0a76756c6c583f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Spin inertia.  <br /></td></tr>
<tr class="separator:a5e224ee273f6971cf0a76756c6c583f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a8b39fe4396923de757fa3071ec2f82"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#a1a8b39fe4396923de757fa3071ec2f82">m_</a> = 1</td></tr>
<tr class="memdesc:a1a8b39fe4396923de757fa3071ec2f82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mass.  <br /></td></tr>
<tr class="separator:a1a8b39fe4396923de757fa3071ec2f82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75137f8b271d5b73c441c88fabfe59d3"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#a75137f8b271d5b73c441c88fabfe59d3">J_</a> = 1</td></tr>
<tr class="memdesc:a75137f8b271d5b73c441c88fabfe59d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Nearest neighbor interaction strength.  <br /></td></tr>
<tr class="separator:a75137f8b271d5b73c441c88fabfe59d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeeaa72dd4e321200f4a9433fb3777098"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#aeeaa72dd4e321200f4a9433fb3777098">U_</a> = 1</td></tr>
<tr class="memdesc:aeeaa72dd4e321200f4a9433fb3777098"><td class="mdescLeft">&#160;</td><td class="mdescRight">Spatial repulsion interaction strength.  <br /></td></tr>
<tr class="separator:aeeaa72dd4e321200f4a9433fb3777098"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c50b38ea116d7b21b34445836e85ee0"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#a2c50b38ea116d7b21b34445836e85ee0">cutoff_</a> = 1</td></tr>
<tr class="memdesc:a2c50b38ea116d7b21b34445836e85ee0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interaction cutoff radius.  <br /></td></tr>
<tr class="separator:a2c50b38ea116d7b21b34445836e85ee0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbb3793a619f6fbf6f160d4a9a2f5487"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classtopology_1_1_vector2d.html">topology::Vector2d</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#acbb3793a619f6fbf6f160d4a9a2f5487">r_</a></td></tr>
<tr class="memdesc:acbb3793a619f6fbf6f160d4a9a2f5487"><td class="mdescLeft">&#160;</td><td class="mdescRight">Particle positions in the group.  <br /></td></tr>
<tr class="separator:acbb3793a619f6fbf6f160d4a9a2f5487"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a542a5c2dad5b7980cc0cfbf19a3b4ba6"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classtopology_1_1_vector2d.html">topology::Vector2d</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#a542a5c2dad5b7980cc0cfbf19a3b4ba6">p_</a></td></tr>
<tr class="memdesc:a542a5c2dad5b7980cc0cfbf19a3b4ba6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Particle momenta/velocities in the group.  <br /></td></tr>
<tr class="separator:a542a5c2dad5b7980cc0cfbf19a3b4ba6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44fc1d0e59c1401e62f98e0a4852b731"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#a44fc1d0e59c1401e62f98e0a4852b731">theta_</a></td></tr>
<tr class="memdesc:a44fc1d0e59c1401e62f98e0a4852b731"><td class="mdescLeft">&#160;</td><td class="mdescRight">Particle spin angles in the group.  <br /></td></tr>
<tr class="separator:a44fc1d0e59c1401e62f98e0a4852b731"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90512f77b5ad86c99a1b565078eaf537"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#a90512f77b5ad86c99a1b565078eaf537">w_</a></td></tr>
<tr class="memdesc:a90512f77b5ad86c99a1b565078eaf537"><td class="mdescLeft">&#160;</td><td class="mdescRight">Particle spin momenta in the group.  <br /></td></tr>
<tr class="separator:a90512f77b5ad86c99a1b565078eaf537"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a187afae51fc68fd66b5c230d404cea0a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpartition.html">partition</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#a187afae51fc68fd66b5c230d404cea0a">partition_</a></td></tr>
<tr class="memdesc:a187afae51fc68fd66b5c230d404cea0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partition (cell list) for neighborhood interaction.  <br /></td></tr>
<tr class="separator:a187afae51fc68fd66b5c230d404cea0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03237769d3d2a8f936de6683f58d6810"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#a03237769d3d2a8f936de6683f58d6810">nb_rule_</a></td></tr>
<tr class="memdesc:a03237769d3d2a8f936de6683f58d6810"><td class="mdescLeft">&#160;</td><td class="mdescRight">Neighbor calculation rule. Possible values: "bruteforce", "all", "ur" for full, (partition with) all and (partition with) upper right neighbors.  <br /></td></tr>
<tr class="separator:a03237769d3d2a8f936de6683f58d6810"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15a89f93f15ae6e305944194244efc46"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#a15a89f93f15ae6e305944194244efc46">nb_mult_factor_</a></td></tr>
<tr class="memdesc:a15a89f93f15ae6e305944194244efc46"><td class="mdescLeft">&#160;</td><td class="mdescRight">If neighbor rule leads to double counting, this factor has to be .5, otherwise 1.  <br /></td></tr>
<tr class="separator:a15a89f93f15ae6e305944194244efc46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf1af218f4fdaee805c20012d4305ab1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classneighbor__list.html">neighbor_list</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#adf1af218f4fdaee805c20012d4305ab1">nb_list_</a></td></tr>
<tr class="memdesc:adf1af218f4fdaee805c20012d4305ab1"><td class="mdescLeft">&#160;</td><td class="mdescRight">neighbor-list  <br /></td></tr>
<tr class="separator:adf1af218f4fdaee805c20012d4305ab1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a290ee2d978475279ecb2ee7b673d637f"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#a290ee2d978475279ecb2ee7b673d637f">lattice_type_</a></td></tr>
<tr class="memdesc:a290ee2d978475279ecb2ee7b673d637f"><td class="mdescLeft">&#160;</td><td class="mdescRight">lattice type. (type 's': square, type 't': trigonal, type 'n': none (mxy model etc))  <br /></td></tr>
<tr class="separator:a290ee2d978475279ecb2ee7b673d637f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47795c0f0f247447e23a541045e8116b"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#a47795c0f0f247447e23a541045e8116b">vm_eta_</a></td></tr>
<tr class="memdesc:a47795c0f0f247447e23a541045e8116b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vicsek model parameter eta: Angle for random noise.  <br /></td></tr>
<tr class="separator:a47795c0f0f247447e23a541045e8116b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac960a4b811c77a828eff4f542d00d243"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgroup.html#ac960a4b811c77a828eff4f542d00d243">vm_v_</a></td></tr>
<tr class="memdesc:ac960a4b811c77a828eff4f542d00d243"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vicsek model parameter v: Streaming velocity.  <br /></td></tr>
<tr class="separator:ac960a4b811c77a828eff4f542d00d243"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A group of polar particles. Stores vectors with particle positions, velocities, spin orientations and spin rotation velocity, as well as further group properties. </p>
<p>Contains the main data to be manipulated in a simulation of the MXY model and the other models.</p>
<p>Functionalities</p>
<ul>
<li>Constructors</li>
<li>Functions for clearing and initialization as well as handling the partition member variable</li>
<li>Operations for reading and copying from other groups</li>
<li>Printing operations</li>
<li>Simple information extraction</li>
<li>Simple arithmetic operations on individual particles and their properties (differences, scaling, setting to new values etc.)</li>
<li>Calculation of physical properties (kinetic temperature, energz, momentum, helicity etc.)</li>
<li>Calculation of field fluctuations</li>
<li>Calculation for spatial and temporal correlation functions as well as correlations in reciprocal space</li>
<li>Calculation of time derivatives</li>
</ul>
<dl class="section author"><dt>Author</dt><dd>Thomas Bissinger</dd></dl>
<dl class="section date"><dt>Date</dt><dd>Created: 2020-02-29 (full rewrite) </dd>
<dd>
Last Updated: 2023-07-23 </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ad9d5836aea085e5b55ecb077d15a6189" name="ad9d5836aea085e5b55ecb077d15a6189"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9d5836aea085e5b55ecb077d15a6189">&#9670;&#160;</a></span>group() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">group::group </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af20a8ed575914e6ee1a2d3b0504633e7" name="af20a8ed575914e6ee1a2d3b0504633e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af20a8ed575914e6ee1a2d3b0504633e7">&#9670;&#160;</a></span>group() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">group::group </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classparameters.html">parameters</a> &amp;&#160;</td>
          <td class="paramname"><em>par</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor from values stored in parameters. Only sets simulation parameters, does not initialize particle data. </p>

</div>
</div>
<a id="acf8ae64992b806f704a91c5ec33d8047" name="acf8ae64992b806f704a91c5ec33d8047"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf8ae64992b806f704a91c5ec33d8047">&#9670;&#160;</a></span>group() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">group::group </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>group_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reduced constructor, useful for time derivative group. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a28fc1d3cc5bb465208b95e965ae2c45d" name="a28fc1d3cc5bb465208b95e965ae2c45d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28fc1d3cc5bb465208b95e965ae2c45d">&#9670;&#160;</a></span>accumulative_MSD()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void group::accumulative_MSD </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>MSD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgroup.html">group</a> &amp;&#160;</td>
          <td class="paramname"><em>last_G</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as coord_diff, but adding the difference to an MSD vector. </p>

</div>
</div>
<a id="ac4349a3a0eee77c0a54b8d31fab867ea" name="ac4349a3a0eee77c0a54b8d31fab867ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4349a3a0eee77c0a54b8d31fab867ea">&#9670;&#160;</a></span>add_random_angle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void group::add_random_angle </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>angmax</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a uniformly distributed angle in (-angmax, angmax) to each particle's theta_. </p>

</div>
</div>
<a id="ab3a441f450ac0f0ffdd385afe8f2b933" name="ab3a441f450ac0f0ffdd385afe8f2b933"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3a441f450ac0f0ffdd385afe8f2b933">&#9670;&#160;</a></span>add_random_displacement()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void group::add_random_displacement </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rmax</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a uniformly distributed displacement (-rmax, rmax)^2 to each particle's r_. </p>

</div>
</div>
<a id="a9dc6a672cd4ece35b5f640ec2ea8d608" name="a9dc6a672cd4ece35b5f640ec2ea8d608"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dc6a672cd4ece35b5f640ec2ea8d608">&#9670;&#160;</a></span>add_to_coord()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void group::add_to_coord </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>coord</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>factor</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds vector of coord to all coordinates (r and theta, if available). Vector must have length of at least N_. Vector of doubles. Does nothing for Vicsek type models. </p>

</div>
</div>
<a id="a5eccd34052a84901037bd3a3bc6c6b48" name="a5eccd34052a84901037bd3a3bc6c6b48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5eccd34052a84901037bd3a3bc6c6b48">&#9670;&#160;</a></span>add_to_coord_inertialscaling()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void group::add_to_coord_inertialscaling </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>coord</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>factor</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds vector of coord to all coordinates (r and theta, if available). Scales by factor and inverse intertia (1/m or 1/I, respectively). Vector must have length of at least N_. Vector of doubles. Does nothing for Vicsek type models. </p>

</div>
</div>
<a id="a951317bf5136ec8a0b2692550ad8e491" name="a951317bf5136ec8a0b2692550ad8e491"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a951317bf5136ec8a0b2692550ad8e491">&#9670;&#160;</a></span>add_to_mom()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void group::add_to_mom </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>mom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>factor</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds vector of mom to momenta (w and p, if available), scales by factor. Vector must have length of at least N_. Vector of doubles. Does nothing for Vicsek type models. </p>

</div>
</div>
<a id="a865745e8a8e7a22b9553041eeba04738" name="a865745e8a8e7a22b9553041eeba04738"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a865745e8a8e7a22b9553041eeba04738">&#9670;&#160;</a></span>add_to_p() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void group::add_to_p </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>factor</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds vector of p to p_, scales by factor. Vector must have length of at least N_. Vector of <a class="el" href="classtopology_1_1_vector2d.html" title="Mathematical 2d vectors. Can be added, multiplied by a scalar, norm computation is possible....">topology::Vector2d</a>. </p>

</div>
</div>
<a id="a4c02d72519fadd3bd3426206e40502f4" name="a4c02d72519fadd3bd3426206e40502f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c02d72519fadd3bd3426206e40502f4">&#9670;&#160;</a></span>add_to_p() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void group::add_to_p </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classtopology_1_1_vector2d.html">topology::Vector2d</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>factor</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds vector of p to p_, scales by factor. Vector must have length of at least N_. Vector of doubles. </p>

</div>
</div>
<a id="a326a53a4ffa5f276ff24138f5e31b23f" name="a326a53a4ffa5f276ff24138f5e31b23f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a326a53a4ffa5f276ff24138f5e31b23f">&#9670;&#160;</a></span>add_to_r() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void group::add_to_r </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>factor</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds vector of r to r_, scales by factor. Vector must have length of at least N_. Vecot of <a class="el" href="classtopology_1_1_vector2d.html" title="Mathematical 2d vectors. Can be added, multiplied by a scalar, norm computation is possible....">topology::Vector2d</a>. </p>

</div>
</div>
<a id="aa1a55666191d6773ef379565e9d3af3d" name="aa1a55666191d6773ef379565e9d3af3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1a55666191d6773ef379565e9d3af3d">&#9670;&#160;</a></span>add_to_r() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void group::add_to_r </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classtopology_1_1_vector2d.html">topology::Vector2d</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>factor</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds vector of r to r_, scales by factor. Vector must have length of at least 2 * N_. Vector of doubles. </p>

</div>
</div>
<a id="a1adc9e9f819e6d3c5b42c66c8f039b09" name="a1adc9e9f819e6d3c5b42c66c8f039b09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1adc9e9f819e6d3c5b42c66c8f039b09">&#9670;&#160;</a></span>add_to_theta()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void group::add_to_theta </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>factor</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds vector of theta to theta_, scales by factor. Vector must have length of at least N_. Vector of doubles. </p>

</div>
</div>
<a id="af224e8ccdd5cb0270cffb74e5d29d1eb" name="af224e8ccdd5cb0270cffb74e5d29d1eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af224e8ccdd5cb0270cffb74e5d29d1eb">&#9670;&#160;</a></span>add_to_w()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void group::add_to_w </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>factor</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds vector of w to w_, scales by factor. Vector must have length of at least N_. Vector of doubles. </p>

</div>
</div>
<a id="a3114842264203a2c14c1c16feea2d417" name="a3114842264203a2c14c1c16feea2d417"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3114842264203a2c14c1c16feea2d417">&#9670;&#160;</a></span>binder_cumulant()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double group::binder_cumulant </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Binder cumulant. 1 - &lt;s^4&gt; / (3 &lt;s^2&gt;). Intensive. </p>

</div>
</div>
<a id="a8e65f260fd3890a6da740e95be012103" name="a8e65f260fd3890a6da740e95be012103"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e65f260fd3890a6da740e95be012103">&#9670;&#160;</a></span>calc_ACF_anglediff()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double group::calc_ACF_anglediff </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgroup.html">group</a> &amp;&#160;</td>
          <td class="paramname"><em>G_initial</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the angle difference autocorrelation-function averaged over all indices. </p>
<p>Computes \( \frac{1}{N}\sum_{i=1}^N (\theta_i^{\texttt{G\_initial}}
- \theta_i^{\texttt{G}})^2\), where \(\theta_i^{\texttt{G\_initial}}\) is the i-th spin angle in group G_initial and \(\theta_i^{\texttt{G}}\) is the i-th spin angle in the current instance of group for which calc_ACF_anglediff is called. </p>

</div>
</div>
<a id="a89bd90c457c1675a5365dcd7351798dd" name="a89bd90c457c1675a5365dcd7351798dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89bd90c457c1675a5365dcd7351798dd">&#9670;&#160;</a></span>calc_ACF_q0()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double group::calc_ACF_q0 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgroup.html">group</a> &amp;&#160;</td>
          <td class="paramname"><em>G_initial</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the (q=0)-autocorrelation-function for some quantity specified by name. </p>
<p>Computes \( \frac{1}{N}\sum_{i=1}^N \big\langle a_i^{\texttt{G\_initial}} \cdot a_i^{\texttt{G}} \big\rangle\), where \(a_i\) is a quantity defined for each particle individually. \(a_i^{\texttt{G\_initial}}\) is then the quantity associated to the i-th particle in the group G_initial, while \(a_i^{\texttt{G}}\) the the quantity associated to the i-th particle in the current instance of group for which calc_ACF_sp is called.</p>
<p><b>Improvement possibilities</b></p>
<ul>
<li><em>Case handling</em>. Case handling for different names follows syntactic simplicity. One could rewrite the code to drastically reduce calls to if-cases.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">G_initial</td><td>group with which the correlation is to be compared. In most cases, this is the simulated group at a previous time. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Used to choose a specific correlation function to be calcualted. Options are <a class="anchor" id="multi_row"></a>
<table class="doxtable">
<caption>Values of name</caption>
<tr>
<th>name value </th><th>Operation </th></tr>
<tr>
<td>"S" </td><td>\(a_i = \mathbf{s}_i\), same as calc_ACF_S </td></tr>
<tr>
<td>"Sx" </td><td>\(a_i = s_{i,x}\), x-component of spin </td></tr>
<tr>
<td>"anglediff" </td><td>\(a_i = \theta_{i}\), averges over \((\theta_i^{\texttt{G\_initial}}
                                        - \theta_i^{\texttt{G}})^2\). See calc_ACF_anglediff </td></tr>
<tr>
<td>"Spar" </td><td>\(a_i = s_{i,\parallel}\), that is spins oriented along the total magnetization angle </td></tr>
<tr>
<td>"Sperp" </td><td>\(a_i = s_{i,\perp}\), that is spins oriented perpendicular to the total magnetization angle </td></tr>
<tr>
<td>"P" </td><td>\(a_i = \mathbf{p}_i\), linear momentum </td></tr>
<tr>
<td>"Px" </td><td>\(a_i = \mathbf{p}_{i,x}\), x-component of linear momentum </td></tr>
<tr>
<td>"Py" </td><td>\(a_i = \mathbf{p}_{i,y}\), y-component of linear momentum </td></tr>
<tr>
<td>"Ppar" </td><td>\(a_i = \mathbf{p}_{i,\parallel}\), component of linear momentum parallel to the total magnetization </td></tr>
<tr>
<td>"Pperp" </td><td>\(a_i = \mathbf{p}_{i,\perp}\), component of linear momentum perpendicular to the total magnetization </td></tr>
<tr>
<td>"W" </td><td>\(a_i = \omega_{i}\), spin momentum </td></tr>
<tr>
<td>"E" </td><td>\(a_i = e_{i}\), energy per particle </td></tr>
<tr>
<td>"Ekin" </td><td>\(a_i = e_{\textrm{kin},i}\), kinetic energy per particle </td></tr>
<tr>
<td>"Eint" </td><td>\(a_i = e_{\textrm{int},i}\), interaction energy per particle </td></tr>
<tr>
<td>"MSD" </td><td>Averages over \(\big(\mathbf{r}_i^{\texttt{G}} - \mathbf{r}_i^{\texttt{G\_initial}}\big)^2\). Careful, does not take periodic boundary into consideration </td></tr>
<tr>
<td>Other </td><td>For any other entry, the return value is set to 0. A warning is printed to std::cerr. </td></tr>
</table>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a32348ae34fde015c4573e29a9418ea40" name="a32348ae34fde015c4573e29a9418ea40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32348ae34fde015c4573e29a9418ea40">&#9670;&#160;</a></span>calc_ACF_S()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double group::calc_ACF_S </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgroup.html">group</a> &amp;&#160;</td>
          <td class="paramname"><em>G_initial</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the spin autocorrelation-function averaged over all indices. </p>
<p>Computes \( \frac{1}{N}\sum_{i=1}^N \mathbf{s}_i^{\texttt{G}} \cdot \mathbf{s}^{\texttt{G\_initial}}\), where \(\mathbf{s}_i^{\texttt{G\_initial}}\) is the i-th spin in the group G_initial and \(\mathbf{s}_i^{\texttt{G}}\) is the i-th spin in the current instance of group for which calc_ACF_S is called. </p>

</div>
</div>
<a id="a2713c59d11edc237520da530ea6aab13" name="a2713c59d11edc237520da530ea6aab13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2713c59d11edc237520da530ea6aab13">&#9670;&#160;</a></span>calc_ACF_sp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double group::calc_ACF_sp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgroup.html">group</a> &amp;&#160;</td>
          <td class="paramname"><em>G_initial</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the single-particle autocorrelation-function for some quantity specified by name. </p>
<p>Computes \( \frac{1}{N}\sum_{i=1}^N \big\langle a_i^{\texttt{G\_initial}} \cdot a_i^{\texttt{G}} \big\rangle\), where \(a_i\) is a quantity defined for each particle individually. \(a_i^{\texttt{G\_initial}}\) is then the quantity associated to the i-th particle in the group G_initial, while \(a_i^{\texttt{G}}\) the the quantity associated to the i-th particle in the current instance of group for which calc_ACF_sp is called.</p>
<p><b>Improvement possibilities</b></p>
<ul>
<li><em>Case handling</em>. Case handling for different names follows syntactic simplicity. One could rewrite the code to drastically reduce calls to if-cases.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">G_initial</td><td>group with which the correlation is to be compared. In most cases, this is the simulated group at a previous time. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Used to choose a specific correlation function to be calcualted. Options are <a class="anchor" id="multi_row"></a>
<table class="doxtable">
<caption>Values of name</caption>
<tr>
<th>name value </th><th>Operation </th></tr>
<tr>
<td>"S" </td><td>\(a_i = \mathbf{s}_i\), same as calc_ACF_S </td></tr>
<tr>
<td>"Sx" </td><td>\(a_i = s_{i,x}\), x-component of spin </td></tr>
<tr>
<td>"anglediff" </td><td>\(a_i = \theta_{i}\), averges over \((\theta_i^{\texttt{G\_initial}}
                                        - \theta_i^{\texttt{G}})^2\). See calc_ACF_anglediff </td></tr>
<tr>
<td>"Spar" </td><td>\(a_i = s_{i,\parallel}\), that is spins oriented along the total magnetization angle </td></tr>
<tr>
<td>"Sperp" </td><td>\(a_i = s_{i,\perp}\), that is spins oriented perpendicular to the total magnetization angle </td></tr>
<tr>
<td>"P" </td><td>\(a_i = \mathbf{p}_i\), linear momentum </td></tr>
<tr>
<td>"Px" </td><td>\(a_i = \mathbf{p}_{i,x}\), x-component of linear momentum </td></tr>
<tr>
<td>"Py" </td><td>\(a_i = \mathbf{p}_{i,y}\), y-component of linear momentum </td></tr>
<tr>
<td>"Ppar" </td><td>\(a_i = \mathbf{p}_{i,\parallel}\), component of linear momentum parallel to the total magnetization </td></tr>
<tr>
<td>"Pperp" </td><td>\(a_i = \mathbf{p}_{i,\perp}\), component of linear momentum perpendicular to the total magnetization </td></tr>
<tr>
<td>"W" </td><td>\(a_i = \omega_{i}\), spin momentum </td></tr>
<tr>
<td>"E" </td><td>\(a_i = e_{i}\), energy per particle </td></tr>
<tr>
<td>"Ekin" </td><td>\(a_i = e_{\textrm{kin},i}\), kinetic energy per particle </td></tr>
<tr>
<td>"Eint" </td><td>\(a_i = e_{\textrm{int},i}\), interaction energy per particle </td></tr>
<tr>
<td>"MSD" </td><td>Averages over \(\big(\mathbf{r}_i^{\texttt{G}} - \mathbf{r}_i^{\texttt{G\_initial}}\big)^2\). Careful, does not take periodic boundary into consideration </td></tr>
<tr>
<td>Other </td><td>For any other entry, the return value is set to 0. A warning is printed to std::cerr. </td></tr>
</table>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a542808253fe680dd21ed20716d90bfc3" name="a542808253fe680dd21ed20716d90bfc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a542808253fe680dd21ed20716d90bfc3">&#9670;&#160;</a></span>calc_current()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtopology_1_1_vector2d.html">topology::Vector2d</a> group::calc_current </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>currentname</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the current for the quantity specified in currentname. currentname = {"tau","je"}. NOT CORRECT FOR THE MOBILE CASE. </p>

</div>
</div>
<a id="a659cc51e831f8d1661c06c9997ca56c6" name="a659cc51e831f8d1661c06c9997ca56c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a659cc51e831f8d1661c06c9997ca56c6">&#9670;&#160;</a></span>calc_eiqr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::complex&lt; double &gt; group::calc_eiqr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtopology_1_1_vector2d.html">topology::Vector2d</a>&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates e^(i q r_i) for particle i. </p>

</div>
</div>
<a id="ade654ed5c479fa2f7637c41dc12d6f15" name="ade654ed5c479fa2f7637c41dc12d6f15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade654ed5c479fa2f7637c41dc12d6f15">&#9670;&#160;</a></span>calc_energy() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double group::calc_energy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns system energy. Extensive. </p>

</div>
</div>
<a id="aee18071ecd1eaa245ac097382f89b0b8" name="aee18071ecd1eaa245ac097382f89b0b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee18071ecd1eaa245ac097382f89b0b8">&#9670;&#160;</a></span>calc_energy() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double group::calc_energy </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Energy of particle i. Extensive. </p>

</div>
</div>
<a id="a4a1aacbfee5f6c7c303fd54afa9637c7" name="a4a1aacbfee5f6c7c303fd54afa9637c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a1aacbfee5f6c7c303fd54afa9637c7">&#9670;&#160;</a></span>calc_eq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::complex&lt; double &gt; group::calc_eq </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtopology_1_1_vector2d.html">topology::Vector2d</a>&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>E_0</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates $e_{q}$ (see Bissinger PhD thesis) and <a class="el" href="classgroup.html#a82e650581e00e2fa5f4eddde45180fd9">calc_fieldfluct </a>. </p>

</div>
</div>
<a id="a82e650581e00e2fa5f4eddde45180fd9" name="a82e650581e00e2fa5f4eddde45180fd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82e650581e00e2fa5f4eddde45180fd9">&#9670;&#160;</a></span>calc_fieldfluct()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">group::calc_fieldfluct </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classtopology_1_1_vector2d.html">topology::Vector2d</a> &gt;&#160;</td>
          <td class="paramname"><em>qvals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>fluctname</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the field fluctuation for the quantity specified in fluctname. </p>
<p>A field fluctuation is a quantity  </p><p class="formulaDsp">
\[
    a_{\mathbf{q}} = \frac{1}{\sqrt{N}} \sum_j a_j e^{-i \mathbf{q}\cdot\mathbf{r}_j}
\]
</p>
<p> for some property \(a_j\) carried by each particle.</p>
<p>This function obtains the value of the field fluctuation at all values of \(\mathbf{q}\) stored in the vector qvals. The type of the field fluctuation is defined by the value of fluctname.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">qvals</td><td>Vector containing the wavevectors \(\mathbf{q}\) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fluctname</td><td>Name of the fluctuation, specifies which one to compute <a class="anchor" id="multi_row"></a>
<table class="doxtable">
<caption>Values of fluctname</caption>
<tr>
<th>name value </th><th>\(a_\mathbf{q}\) </th><th>\(a_i\) </th><th>Meaning </th></tr>
<tr>
<td>"mxq" </td><td>\(m_{x,\mathbf{q}}\) </td><td>\(s_{i,x}\) </td><td>Magnetization in x-direction </td></tr>
<tr>
<td>"myq" </td><td>\(m_{y,\mathbf{q}}\) </td><td>\(s_{i,y}\) </td><td>Magnetization in y-direction </td></tr>
<tr>
<td>"wq" </td><td>\(w_{\mathbf{q}}\) </td><td>\(\omega_i\) </td><td>Spin angular momentum </td></tr>
<tr>
<td>"eq" </td><td>\(e_{\mathbf{q}}\) </td><td>\(e_i\) </td><td>Energy density </td></tr>
<tr>
<td>"teq" </td><td>\(\theta_{\mathbf{q}}\) </td><td>\(\theta_i\) </td><td>Spin angle (not recommended to use) </td></tr>
<tr>
<td>"rq" </td><td>\(\rho_{\mathbf{q}}\) </td><td>\(1\) </td><td>Density </td></tr>
<tr>
<td>"lq" </td><td>\(l_{\mathbf{q}}\) </td><td>\(l_i\) </td><td>Spatial angular momentum (not recommended to use) </td></tr>
<tr>
<td>"jparq" </td><td>\(j_{\parallel,\mathbf{q}}\) </td><td>\(v_{i}^{\parallel}\) </td><td>Longitudinal velocity fluctuation (along \(\mathbf{q}\)) </td></tr>
<tr>
<td>"jparq" </td><td>\(j_{\perp,\mathbf{q}}\) </td><td>\(v_{i}^{\perp}\) </td><td>Transversal velocity fluctuation (perpendicular to \(\mathbf{q}\)) </td></tr>
<tr>
<td>Other </td><td>&ndash; </td><td>&ndash; </td><td>For any other entry, the return value is set to 0. A warning is printed to std::cerr. </td></tr>
</table>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac815d41c4492553f0748846df521f5da" name="ac815d41c4492553f0748846df521f5da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac815d41c4492553f0748846df521f5da">&#9670;&#160;</a></span>calc_fieldfluct_average()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double group::calc_fieldfluct_average </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>fluctname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtopology_1_1_vector2d.html">topology::Vector2d</a>&#160;</td>
          <td class="paramname"><em>q</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the average of the field fluctuation fluctname. (e.g. for "wq" this returns sum omega_i.) </p>
<p>For further details on the variable fluctname, see <a class="el" href="classgroup.html#a82e650581e00e2fa5f4eddde45180fd9">calc_fieldfluct </a> </p>

</div>
</div>
<a id="a3b13aa6835031fc76780148ab9cc4434" name="a3b13aa6835031fc76780148ab9cc4434"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b13aa6835031fc76780148ab9cc4434">&#9670;&#160;</a></span>calc_fieldfluct_convolution()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::complex&lt; double &gt; &gt; group::calc_fieldfluct_convolution </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classtopology_1_1_vector2d.html">topology::Vector2d</a> &gt;&#160;</td>
          <td class="paramname"><em>qvals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>fluctname_1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>fluctname_2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the field fluctuation for the quantity specified in fluctname. </p>

</div>
</div>
<a id="a72b9e36213857ea0b2cf44752d0ca077" name="a72b9e36213857ea0b2cf44752d0ca077"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72b9e36213857ea0b2cf44752d0ca077">&#9670;&#160;</a></span>calc_helicity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; group::calc_helicity </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>beta</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the helicity modulus and auxiliary quantities. Output is a vector with entries (Upsilon,H_x,H_y,I_x,I_y) </p>

</div>
</div>
<a id="a3a4be7da7f0f4e32ee66d64f05639ada" name="a3a4be7da7f0f4e32ee66d64f05639ada"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a4be7da7f0f4e32ee66d64f05639ada">&#9670;&#160;</a></span>calc_interaction_energy() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double group::calc_interaction_energy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>System interaction energy. Extensive. </p>

</div>
</div>
<a id="aa19ffd58dbb8f5ec1e99b1dd5087adf0" name="aa19ffd58dbb8f5ec1e99b1dd5087adf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa19ffd58dbb8f5ec1e99b1dd5087adf0">&#9670;&#160;</a></span>calc_interaction_energy() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double group::calc_interaction_energy </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interaction energy of particle i. </p>

</div>
</div>
<a id="a2f819a6f9ebdb8d49f7f77c659fbc94d" name="a2f819a6f9ebdb8d49f7f77c659fbc94d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f819a6f9ebdb8d49f7f77c659fbc94d">&#9670;&#160;</a></span>calc_je()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtopology_1_1_vector2d.html">topology::Vector2d</a> group::calc_je </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates \(j^e\), as defined for the xy model. NOT CORRECT FOR THE MOBILE CASE. </p>

</div>
</div>
<a id="a570ebbe5db9eb12267985d724b7b9b22" name="a570ebbe5db9eb12267985d724b7b9b22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a570ebbe5db9eb12267985d724b7b9b22">&#9670;&#160;</a></span>calc_jq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::complex&lt; double &gt; &gt; group::calc_jq </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtopology_1_1_vector2d.html">topology::Vector2d</a>&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtopology_1_1_vector2d.html">topology::Vector2d</a>&#160;</td>
          <td class="paramname"><em>J_0</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates $j_{q}$ (see Bissinger PhD thesis) and <a class="el" href="classgroup.html#a82e650581e00e2fa5f4eddde45180fd9">calc_fieldfluct </a>. </p>

</div>
</div>
<a id="ac17cd8d0b2c4ffac7e6a5c1027bfcc95" name="ac17cd8d0b2c4ffac7e6a5c1027bfcc95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac17cd8d0b2c4ffac7e6a5c1027bfcc95">&#9670;&#160;</a></span>calc_jqpar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::complex&lt; double &gt; group::calc_jqpar </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtopology_1_1_vector2d.html">topology::Vector2d</a>&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtopology_1_1_vector2d.html">topology::Vector2d</a>&#160;</td>
          <td class="paramname"><em>J_0</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates $j_{q,L}$ (see Bissinger PhD thesis) and <a class="el" href="classgroup.html#a82e650581e00e2fa5f4eddde45180fd9">calc_fieldfluct </a>. </p>

</div>
</div>
<a id="afd3874e3abc2733663ceb07f2c1dd465" name="afd3874e3abc2733663ceb07f2c1dd465"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd3874e3abc2733663ceb07f2c1dd465">&#9670;&#160;</a></span>calc_jqperp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::complex&lt; double &gt; group::calc_jqperp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtopology_1_1_vector2d.html">topology::Vector2d</a>&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtopology_1_1_vector2d.html">topology::Vector2d</a>&#160;</td>
          <td class="paramname"><em>J_0</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates $j_{q,T}$ (see Bissinger PhD thesis) and <a class="el" href="classgroup.html#a82e650581e00e2fa5f4eddde45180fd9">calc_fieldfluct </a>. </p>

</div>
</div>
<a id="a93b89d7f402d699ae1fbaeca09b894f1" name="a93b89d7f402d699ae1fbaeca09b894f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93b89d7f402d699ae1fbaeca09b894f1">&#9670;&#160;</a></span>calc_kinetic_energy() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double group::calc_kinetic_energy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns system energy. Extensive. </p>

</div>
</div>
<a id="a7c536814249a31417d693d92563d5bf2" name="a7c536814249a31417d693d92563d5bf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c536814249a31417d693d92563d5bf2">&#9670;&#160;</a></span>calc_kinetic_energy() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double group::calc_kinetic_energy </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns kinetic energy of particle i. </p>

</div>
</div>
<a id="a9478386c54ff4f2528fef370390fd5db" name="a9478386c54ff4f2528fef370390fd5db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9478386c54ff4f2528fef370390fd5db">&#9670;&#160;</a></span>calc_lq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::complex&lt; double &gt; group::calc_lq </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtopology_1_1_vector2d.html">topology::Vector2d</a>&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>L_0</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates $l_{q}$ (see Bissinger PhD thesis) and <a class="el" href="classgroup.html#a82e650581e00e2fa5f4eddde45180fd9">calc_fieldfluct </a>. </p>

</div>
</div>
<a id="a4f857cb3c2706998ae4f19e522297fd9" name="a4f857cb3c2706998ae4f19e522297fd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f857cb3c2706998ae4f19e522297fd9">&#9670;&#160;</a></span>calc_mxq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::complex&lt; double &gt; group::calc_mxq </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtopology_1_1_vector2d.html">topology::Vector2d</a>&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>Mx_0</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates $m_{x,q}$ (see Bissinger PhD thesis) and <a class="el" href="classgroup.html#a82e650581e00e2fa5f4eddde45180fd9">calc_fieldfluct </a>. </p>

</div>
</div>
<a id="a80e571e014722e2aa44fa52e15f2e24e" name="a80e571e014722e2aa44fa52e15f2e24e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80e571e014722e2aa44fa52e15f2e24e">&#9670;&#160;</a></span>calc_myq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::complex&lt; double &gt; group::calc_myq </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtopology_1_1_vector2d.html">topology::Vector2d</a>&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>My_0</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates $m_{y,q}$ (see Bissinger PhD thesis) and <a class="el" href="classgroup.html#a82e650581e00e2fa5f4eddde45180fd9">calc_fieldfluct </a>. </p>

</div>
</div>
<a id="a7918e895717ed9b4825aa70ad2c9ad15" name="a7918e895717ed9b4825aa70ad2c9ad15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7918e895717ed9b4825aa70ad2c9ad15">&#9670;&#160;</a></span>calc_neighbor_mean()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double group::calc_neighbor_mean </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>te_pow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>r_pow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>cos_pow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sin_pow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>J_pow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>Up_pow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>Upp_pow</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the mean over nearest neighbors. </p>
<p>For each pair of particles, the function determines "theta^te_pow * r^r_pow * cos(theta)^cos_pow * sin(theta)^sin_pow * J(r)^J_pow * U'(r)^Up_pow  * U''(r)^Upp_pow" and adds all the values up. Here, theta is the spin angle difference between the two particles, r is the distance between the particles. Can be used to calculate transport coefficients or other diagnostics. </p>

</div>
</div>
<a id="ac3073bfec2b6adb914cf5f26e5c0de32" name="ac3073bfec2b6adb914cf5f26e5c0de32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3073bfec2b6adb914cf5f26e5c0de32">&#9670;&#160;</a></span>calc_one_particle_density()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double group::calc_one_particle_density </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>fluctname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtopology_1_1_vector2d.html">topology::Vector2d</a>&#160;</td>
          <td class="paramname"><em>q</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the one-particle density associated with the field fluctuation fluctname. (e.g. for "wq" this returns omega_index.) </p>
<p>For further details on the variable fluctname, see <a class="el" href="classgroup.html#a82e650581e00e2fa5f4eddde45180fd9">calc_fieldfluct </a> </p>

</div>
</div>
<a id="ae1789f66f507ed05dbc84b1f3331a4be" name="ae1789f66f507ed05dbc84b1f3331a4be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1789f66f507ed05dbc84b1f3331a4be">&#9670;&#160;</a></span>calc_rq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::complex&lt; double &gt; group::calc_rq </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtopology_1_1_vector2d.html">topology::Vector2d</a>&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates $rho_{q}$ (see Bissinger PhD thesis) and <a class="el" href="classgroup.html#a82e650581e00e2fa5f4eddde45180fd9">calc_fieldfluct </a>. </p>

</div>
</div>
<a id="a4dacb625fe5f1435cc7e4eeb77dae77f" name="a4dacb625fe5f1435cc7e4eeb77dae77f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dacb625fe5f1435cc7e4eeb77dae77f">&#9670;&#160;</a></span>calc_SCF_anglediff_individual()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; group::calc_SCF_anglediff_individual </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt;&#160;</td>
          <td class="paramname"><em>rbin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>counts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the static angle difference correlation function for a specific particle at index. </p>
<p>More precisely, obtains &lt;theta_[index]-theta_[j]&gt; for all j in the sample, sums the results and sorts them into bins. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>Particle index. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rbin</td><td>Bin prescription. Contains bin edges, e.g. rbin = (0,dr,2*dr,...,rmax-dr,rmax) for an equidistant bin. Particles further from the focal particle than rmax are not considered. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">counts</td><td>Counts how many particle are found within a bin. As the function is typically repeatedly to sample many particles, this parameter can be updated for each individual call to the function. Must be initialized to zero before the first call. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa86f4574a2829525d00468c9eb6981a0" name="aa86f4574a2829525d00468c9eb6981a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa86f4574a2829525d00468c9eb6981a0">&#9670;&#160;</a></span>calc_SCF_averaged()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; group::calc_SCF_averaged </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt;&#160;</td>
          <td class="paramname"><em>rbin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>number_of_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the static correlation function specified by name for number_of_points many random particles. </p>
<p>Uses one of the individual SCF calculation functions for number_of_points many randomly chosen particles and averages over the result.</p>
<p><b>Improvement possibilities</b></p>
<ul>
<li><em>Case handling</em>. Case handling for different names follows syntactic simplicity. One could rewrite the code to drastically reduce calls to if-cases.</li>
<li><em>Information efficiency</em>. In this function, points within a specific bin are determined. If one calls for this function repeatedly, these points are always calculated anew. This is a great loss of efficiency and could be mended by more careful code.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rbin</td><td>Bin prescription. Contains bin edges, e.g. rbin = (0,dr,2*dr,...,rmax-dr,rmax) for an equidistant bin. Particles further from the focal particle than rmax are not considered. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">number_of_points</td><td>Determines how often the function calls an SCF_individual function. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Used to choose a specific correlation function to be calcualted. Options are <a class="anchor" id="multi_row"></a>
<table class="doxtable">
<caption>Values of name</caption>
<tr>
<th>name value </th><th>Operation </th></tr>
<tr>
<td>"g" </td><td>uses calc_SCF_g_individual, calculates g(r) </td></tr>
<tr>
<td>"anglediff" </td><td>uses calc_SCF_anglediff_individual, calculates mean angle difference </td></tr>
<tr>
<td>"S" </td><td>uses calc_SCF_S_individual, calculates mean spin alignment </td></tr>
<tr>
<td>"S_par" </td><td>uses calc_SCF_S_oriented_individual with the orientation along the total magnetization angle </td></tr>
<tr>
<td>"S_perp" </td><td>uses calc_SCF_S_oriented_individual with the orientation perpendicular to the total magnetization angle </td></tr>
<tr>
<td>"P" </td><td>uses calc_SCF_P_individual, calculates mean momentum alignment </td></tr>
<tr>
<td>"W" </td><td>uses calc_SCF_W_individual, calculates mean spin momentum correlation </td></tr>
<tr>
<td>"E" </td><td>uses calc_SCF_E_individual, calculates mean energy correlation </td></tr>
<tr>
<td>"Ekin" </td><td>uses calc_SCF_Ekin_individual, calculates mean kinetic energy correlation </td></tr>
<tr>
<td>"Eint" </td><td>uses calc_SCF_Eint_individual, calculates mean interaction energy correlation </td></tr>
<tr>
<td>Other </td><td>For any other entry, the return value is set to 0. A warning is printed to std::cerr. </td></tr>
</table>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aadc8981b3862eef09f21febd56042f6a" name="aadc8981b3862eef09f21febd56042f6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadc8981b3862eef09f21febd56042f6a">&#9670;&#160;</a></span>calc_SCF_E_individual()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; group::calc_SCF_E_individual </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt;&#160;</td>
          <td class="paramname"><em>rbin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>counts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the static total energy correlation function for a specific particle at index. </p>
<p>More precisely, obtains &lt;e(index)*e(j)&gt; for all j in the sample, with e the total energy of a particle, sums the results and sorts them into bins. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>Particle index. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rbin</td><td>Bin prescription. Contains bin edges, e.g. rbin = (0,dr,2*dr,...,rmax-dr,rmax) for an equidistant bin. Particles further from the focal particle than rmax are not considered. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">counts</td><td>Counts how many particle are found within a bin. As the function is typically repeatedly to sample many particles, this parameter can be updated for each individual call to the function. Must be initialized to zero before the first call. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8e7eff1e7b38c8c9b170422d5f5a158c" name="a8e7eff1e7b38c8c9b170422d5f5a158c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e7eff1e7b38c8c9b170422d5f5a158c">&#9670;&#160;</a></span>calc_SCF_Eint_individual()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; group::calc_SCF_Eint_individual </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt;&#160;</td>
          <td class="paramname"><em>rbin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>counts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the static interaction energy correlation function for a specific particle at index. </p>
<p>More precisely, obtains &lt;e_int(index)*e_int(j)&gt; for all j in the sample, with e_int the interaction energy of a particle, sums the results and sorts them into bins. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>Particle index. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rbin</td><td>Bin prescription. Contains bin edges, e.g. rbin = (0,dr,2*dr,...,rmax-dr,rmax) for an equidistant bin. Particles further from the focal particle than rmax are not considered. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">counts</td><td>Counts how many particle are found within a bin. As the function is typically repeatedly to sample many particles, this parameter can be updated for each individual call to the function. Must be initialized to zero before the first call. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a96a49b24c17de671412d332e96acf3ba" name="a96a49b24c17de671412d332e96acf3ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96a49b24c17de671412d332e96acf3ba">&#9670;&#160;</a></span>calc_SCF_Ekin_individual()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; group::calc_SCF_Ekin_individual </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt;&#160;</td>
          <td class="paramname"><em>rbin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>counts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the static kinetic energy correlation function for a specific particle at index. </p>
<p>More precisely, obtains &lt;e_kin(index)*e_kin(j)&gt; for all j in the sample, with e_kin the kinetic energy of a particle, sums the results and sorts them into bins. </p>

</div>
</div>
<a id="ad55bd73ba599cbed393926a61f499a46" name="ad55bd73ba599cbed393926a61f499a46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad55bd73ba599cbed393926a61f499a46">&#9670;&#160;</a></span>calc_SCF_g()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; group::calc_SCF_g </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt;&#160;</td>
          <td class="paramname"><em>rbin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>number_of_points</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the overall pair distribution function g(r) </p>
<p>Uses calc_SCF_g_individual for number_of_points many randomly chosen particles and averages over the result </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rbin</td><td>Bin prescription. Contains bin edges, e.g. rbin = (0,dr,2*dr,...,rmax-dr,rmax) for an equidistant bin. Particles further from the focal particle than rmax are not considered. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">number_of_points</td><td>Determines how often the function calls calc_SCF_g_individual. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad19944292752c21dfe3419c15bf3b8f3" name="ad19944292752c21dfe3419c15bf3b8f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad19944292752c21dfe3419c15bf3b8f3">&#9670;&#160;</a></span>calc_SCF_g_individual()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; group::calc_SCF_g_individual </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt;&#160;</td>
          <td class="paramname"><em>rbin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the pair distribution function g(r) for a specific particle at index. </p>
<p>More precisely, counts particles j within the interval (rbin[k],rbin[k+1]]. The result is multiplied by 2 * pi * rbin[k] * dr[k] * rho, with the density rho and the bin width dr[k] = rbin[k+1] - rbin[k]. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>Particle index. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rbin</td><td>Bin prescription. Contains bin edges, e.g. rbin = (0,dr,2*dr,...,rmax-dr,rmax) for an equidistant bin. Particles further from the focal particle than rmax are not considered. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a91b0fc82c16c8c5dfc77ae079fe577af" name="a91b0fc82c16c8c5dfc77ae079fe577af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91b0fc82c16c8c5dfc77ae079fe577af">&#9670;&#160;</a></span>calc_SCF_P_individual()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; group::calc_SCF_P_individual </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt;&#160;</td>
          <td class="paramname"><em>rbin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>counts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the static momentum correlation function for a specific particle at index. </p>
<p>More precisely, obtains &lt;p_[index]*p[j]&gt; for all j in the sample (meaning the inner product in this case), sums the results and sorts them into bins. </p>

</div>
</div>
<a id="adceefccfc1a29c7428974ebce0f9ecef" name="adceefccfc1a29c7428974ebce0f9ecef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adceefccfc1a29c7428974ebce0f9ecef">&#9670;&#160;</a></span>calc_SCF_S_individual()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; group::calc_SCF_S_individual </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt;&#160;</td>
          <td class="paramname"><em>rbin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>counts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the static spin correlation function for a specific particle at index. </p>
<p>More precisely, obtains &lt;S_index * S_j&gt;=&lt;cos(theta_[index]-theta_[j])&gt; for all j in the sample, sums the results and sorts them into bins. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>Particle index. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rbin</td><td>Bin prescription. Contains bin edges, e.g. rbin = (0,dr,2*dr,...,rmax-dr,rmax) for an equidistant bin. Particles further from the focal particle than rmax are not considered. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">counts</td><td>Counts how many particle are found within a bin. As the function is typically repeatedly to sample many particles, this parameter can be updated for each individual call to the function. Must be initialized to zero before the first call. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a82e24fe33ee6468dfcf7289c71124ef7" name="a82e24fe33ee6468dfcf7289c71124ef7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82e24fe33ee6468dfcf7289c71124ef7">&#9670;&#160;</a></span>calc_SCF_S_oriented_individual()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; group::calc_SCF_S_oriented_individual </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt;&#160;</td>
          <td class="paramname"><em>rbin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>orientation_angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>counts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the static oriented spin correlation function for a specific particle at index. </p>
<p>More precisely, obtains &lt;cos(theta_[index])*cos(theta_[j])&gt; for all j in the sample, sums the results and sorts them into bins. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>Particle index. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rbin</td><td>Bin prescription. Contains bin edges, e.g. rbin = (0,dr,2*dr,...,rmax-dr,rmax) for an equidistant bin. Particles further from the focal particle than rmax are not considered. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">counts</td><td>Counts how many particle are found within a bin. As the function is typically repeatedly to sample many particles, this parameter can be updated for each individual call to the function. Must be initialized to zero before the first call. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae912c98c7c9dd2f937dcf7433052448f" name="ae912c98c7c9dd2f937dcf7433052448f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae912c98c7c9dd2f937dcf7433052448f">&#9670;&#160;</a></span>calc_SCF_W_individual()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; group::calc_SCF_W_individual </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt;&#160;</td>
          <td class="paramname"><em>rbin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>counts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the static spin momentum correlation function for a specific particle at index. </p>
<p>More precisely, obtains &lt;w_[index]*w[j]&gt; for all j in the sample, sums the results and sorts them into bins. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>Particle index. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rbin</td><td>Bin prescription. Contains bin edges, e.g. rbin = (0,dr,2*dr,...,rmax-dr,rmax) for an equidistant bin. Particles further from the focal particle than rmax are not considered. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">counts</td><td>Counts how many particle are found within a bin. As the function is typically repeatedly to sample many particles, this parameter can be updated for each individual call to the function. Must be initialized to zero before the first call. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a72a5b9635814dd9c3f13cde050957405" name="a72a5b9635814dd9c3f13cde050957405"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72a5b9635814dd9c3f13cde050957405">&#9670;&#160;</a></span>calc_space_angular_mom() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double group::calc_space_angular_mom </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns total spatial angular momentum of particles. </p>

</div>
</div>
<a id="ab78f20d5babe58f96031c23dbea95844" name="ab78f20d5babe58f96031c23dbea95844"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab78f20d5babe58f96031c23dbea95844">&#9670;&#160;</a></span>calc_space_angular_mom() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double group::calc_space_angular_mom </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns spatial angular momentum of the particle with index i. </p>

</div>
</div>
<a id="a0a683c6fefe6132e6b4685d4099c23b3" name="a0a683c6fefe6132e6b4685d4099c23b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a683c6fefe6132e6b4685d4099c23b3">&#9670;&#160;</a></span>calc_tau()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtopology_1_1_vector2d.html">topology::Vector2d</a> group::calc_tau </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates \(\tau\), as defined for the xy model. NOT CORRECT FOR THE MOBILE CASE. </p>

</div>
</div>
<a id="af6edf3a06534225562427fab80486a83" name="af6edf3a06534225562427fab80486a83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6edf3a06534225562427fab80486a83">&#9670;&#160;</a></span>calc_TCF()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">group::calc_TCF </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgroup.html">group</a> &amp;&#160;</td>
          <td class="paramname"><em>G_initial</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classtopology_1_1_vector2d.html">topology::Vector2d</a> &gt;&#160;</td>
          <td class="paramname"><em>qvals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>fluctname_initial</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>fluctname_current</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates time-correlation function between two different groups. Fluctuation names must be specified. </p>
<p>Calculates \(a_{\mathbf{q}}^* b_{\mathbf{\qq}}(t)\), or more accurately \((a_{\mathbf{q}}^{\texttt{G\_initial}})^* b_{\mathbf{\qq}}^{\texttt{G}}\), where \(\mathbf{q}\) is a wave vector and \(a_{\mathbf{q}}^{\texttt{G\_initial}}\) and \(b_{\mathbf{q}}^{\texttt{G}}\) are field fluctuations associated with the group \(\texttt{G\_initial}\) and \(\texttt{G}\) (the current instance of group for which calc_TCF is called), respectively.</p>
<p>Returns a vector whose entries correspond to the wavevectors in qvals.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">G_initial</td><td>group with which the correlation is computed. In most cases, this is the simulated group at a previous time. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">qvals</td><td>vector of \(\mathbf{q}\)-values for which the product of field fluctuations is calculated </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fluctname_initial</td><td>specifies \(a_{\mathbf{q}}^{\textttt{G_initial}}\), the field fluctuation of G_initial. For details, see <a class="el" href="classgroup.html#a82e650581e00e2fa5f4eddde45180fd9">calc_fieldfluct </a></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fluctname_current</td><td>specifies \(b_{\mathbf{q}}^{\textttt{G}}\), the field fluctuation in G. For details, see <a class="el" href="classgroup.html#a82e650581e00e2fa5f4eddde45180fd9">calc_fieldfluct </a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab7f8951239c09090c26639828494a93b" name="ab7f8951239c09090c26639828494a93b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7f8951239c09090c26639828494a93b">&#9670;&#160;</a></span>calc_temperature()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double group::calc_temperature </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns temperature. Careful, this function returns ((&lt;p^2&gt;-. </p>
<p>^2)/m + (&lt;w^2&gt;-&lt;w&gt;^2)/I)/3, not the kinetic energy. Intensive. </p>

</div>
</div>
<a id="a03fdfcbbf43dcd0313997740b879c2b5" name="a03fdfcbbf43dcd0313997740b879c2b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03fdfcbbf43dcd0313997740b879c2b5">&#9670;&#160;</a></span>calc_temperature_p()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double group::calc_temperature_p </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns linear momentum temperature. </p>

</div>
</div>
<a id="a6d75ec867ad5dd9086b0a76a274150c8" name="a6d75ec867ad5dd9086b0a76a274150c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d75ec867ad5dd9086b0a76a274150c8">&#9670;&#160;</a></span>calc_temperature_w()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double group::calc_temperature_w </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns spin angular momentum temperature. </p>

</div>
</div>
<a id="ac6bdf3edcf8676059bc5fb0b2d761ce0" name="ac6bdf3edcf8676059bc5fb0b2d761ce0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6bdf3edcf8676059bc5fb0b2d761ce0">&#9670;&#160;</a></span>calc_teq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::complex&lt; double &gt; group::calc_teq </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtopology_1_1_vector2d.html">topology::Vector2d</a>&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>Te_0</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates $theta_{q}$ (see Bissinger PhD thesis) and <a class="el" href="classgroup.html#a82e650581e00e2fa5f4eddde45180fd9">calc_fieldfluct </a>. </p>

</div>
</div>
<a id="a44bcc7bf737e4a51f604491546d2000b" name="a44bcc7bf737e4a51f604491546d2000b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44bcc7bf737e4a51f604491546d2000b">&#9670;&#160;</a></span>calc_vortexdensity_signed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double group::calc_vortexdensity_signed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the signed vortex density (i.e. number of positive vortices minus number of negative vortices divided by box area). </p>

</div>
</div>
<a id="a1cb763408196d3f624462cdd50299160" name="a1cb763408196d3f624462cdd50299160"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cb763408196d3f624462cdd50299160">&#9670;&#160;</a></span>calc_vortexdensity_unsigned()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double group::calc_vortexdensity_unsigned </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the unsigned vortex density (i.e. number of vortices divided by box area). </p>

</div>
</div>
<a id="a05568e37fd285c9d3db91e72cbbaf1e5" name="a05568e37fd285c9d3db91e72cbbaf1e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05568e37fd285c9d3db91e72cbbaf1e5">&#9670;&#160;</a></span>calc_vorticity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double group::calc_vorticity </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns vorticity along the plaquette at index. </p>

</div>
</div>
<a id="adbefb8517df13e29f18f97a5576a72a5" name="adbefb8517df13e29f18f97a5576a72a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbefb8517df13e29f18f97a5576a72a5">&#9670;&#160;</a></span>calc_wq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::complex&lt; double &gt; group::calc_wq </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtopology_1_1_vector2d.html">topology::Vector2d</a>&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>W_0</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates $w_{q}$ (see Bissinger PhD thesis) and <a class="el" href="classgroup.html#a82e650581e00e2fa5f4eddde45180fd9">calc_fieldfluct </a>. </p>

</div>
</div>
<a id="a9a05c6a033e70fc0bee898b55af1eb2d" name="a9a05c6a033e70fc0bee898b55af1eb2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a05c6a033e70fc0bee898b55af1eb2d">&#9670;&#160;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void group::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears particles and partition. </p>

</div>
</div>
<a id="a316a74bbcdad5160b6a106d869a9d84d" name="a316a74bbcdad5160b6a106d869a9d84d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a316a74bbcdad5160b6a106d869a9d84d">&#9670;&#160;</a></span>coord_diff()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; group::coord_diff </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgroup.html">group</a> &amp;&#160;</td>
          <td class="paramname"><em>G</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns coordinate difference between this group and another one, with proper care of boundaries. First N_ entries are theta, then r_x, then r_y. </p>

</div>
</div>
<a id="a2cd4f3e5a31ec3a4f19e7fe0655b2316" name="a2cd4f3e5a31ec3a4f19e7fe0655b2316"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cd4f3e5a31ec3a4f19e7fe0655b2316">&#9670;&#160;</a></span>fill_partition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void group::fill_partition </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fills, i.e. computes the partition. </p>

</div>
</div>
<a id="a2fc0be012241fcee2de13909bdfb1e3e" name="a2fc0be012241fcee2de13909bdfb1e3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fc0be012241fcee2de13909bdfb1e3e">&#9670;&#160;</a></span>generate_neighbor_list()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void group::generate_neighbor_list </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fills the variables nb_index_, nb_first_, nb_dist_ according to the current neighborhood situation. Strongly recommended for fmxy model, recommended for xy and fvm model with small system sizes. </p>

</div>
</div>
<a id="a08b7dfd53858616e08da206455e6df5d" name="a08b7dfd53858616e08da206455e6df5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08b7dfd53858616e08da206455e6df5d">&#9670;&#160;</a></span>get_boxsize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double group::get_boxsize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns smallest box length. </p>

</div>
</div>
<a id="ad8b7b1e77febb8a2afd245304358009e" name="ad8b7b1e77febb8a2afd245304358009e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8b7b1e77febb8a2afd245304358009e">&#9670;&#160;</a></span>get_coord()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; group::get_coord </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns vector of all coordinates (angles theta_ and poitions r_, length 3N) </p>

</div>
</div>
<a id="a77bd98604ac648bbac5198554cf50a79" name="a77bd98604ac648bbac5198554cf50a79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77bd98604ac648bbac5198554cf50a79">&#9670;&#160;</a></span>get_cutoff()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double group::get_cutoff </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns member variable cutoff_ (interaction cutoff length) </p>

</div>
</div>
<a id="aff2998a96bff57f7b721de7ceef1141f" name="aff2998a96bff57f7b721de7ceef1141f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff2998a96bff57f7b721de7ceef1141f">&#9670;&#160;</a></span>get_density()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double group::get_density </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns density. </p>

</div>
</div>
<a id="a18cf499bb765b4424803af9c9d3345e7" name="a18cf499bb765b4424803af9c9d3345e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18cf499bb765b4424803af9c9d3345e7">&#9670;&#160;</a></span>get_group_type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string group::get_group_type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns member variable group_type_ (type of group) </p>

</div>
</div>
<a id="af959f8b307677c95e4b3271f5d6abead" name="af959f8b307677c95e4b3271f5d6abead"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af959f8b307677c95e4b3271f5d6abead">&#9670;&#160;</a></span>get_I()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double group::get_I </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns member variable I_ (spin inertia) </p>

</div>
</div>
<a id="ae6ba547117763b24a0d341fa258fcfd7" name="ae6ba547117763b24a0d341fa258fcfd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6ba547117763b24a0d341fa258fcfd7">&#9670;&#160;</a></span>get_J()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double group::get_J </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns member variable J_ (spin coupling strength) </p>

</div>
</div>
<a id="a809cb802277ce088d2dbc7ccb1531f4b" name="a809cb802277ce088d2dbc7ccb1531f4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a809cb802277ce088d2dbc7ccb1531f4b">&#9670;&#160;</a></span>get_L()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtopology_1_1_vector2d.html">topology::Vector2d</a> group::get_L </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns simulation box size. </p>

</div>
</div>
<a id="a614dc2b2a83fa117ee37b0186b99aae5" name="a614dc2b2a83fa117ee37b0186b99aae5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a614dc2b2a83fa117ee37b0186b99aae5">&#9670;&#160;</a></span>get_m()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double group::get_m </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns member variable m_ (particle mass) </p>

</div>
</div>
<a id="ae360d6121e189e51b55e529f9a074c07" name="ae360d6121e189e51b55e529f9a074c07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae360d6121e189e51b55e529f9a074c07">&#9670;&#160;</a></span>get_mom()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; group::get_mom </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns vector of all momenta (spin momenta w_ and linear momenta p_, length 3N) </p>

</div>
</div>
<a id="a0af365fff45f5342e94fee665b09fe38" name="a0af365fff45f5342e94fee665b09fe38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0af365fff45f5342e94fee665b09fe38">&#9670;&#160;</a></span>get_N()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int group::get_N </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns number of particles. </p>

</div>
</div>
<a id="a8e09f2d17d963087ef510ea37ff7d17b" name="a8e09f2d17d963087ef510ea37ff7d17b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e09f2d17d963087ef510ea37ff7d17b">&#9670;&#160;</a></span>get_neighbors() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; group::get_neighbors </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>cellselect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>distances</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns indices of neighbors of the particle. Selection of cells possible. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>Particle index. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cellselect</td><td>Cell selection command. "all" is for all neighboring cells, "ur" is for the cell of the particle, the three cells above and the cell to the right "single" is just for the cell the particle is in. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">distances</td><td>Stores the distances to all neighbors. Saves computation time. Only filled in case of mobile particles. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8f64beec448f2ed67848f5886250c966" name="a8f64beec448f2ed67848f5886250c966"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f64beec448f2ed67848f5886250c966">&#9670;&#160;</a></span>get_neighbors() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; group::get_neighbors </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>distances</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns indices of neighbors of the particle. Uses the member variable nb_rule_ to determine which cells to select. </p>

</div>
</div>
<a id="ad288525b31316ed5142d1ef6ab4c5115" name="ad288525b31316ed5142d1ef6ab4c5115"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad288525b31316ed5142d1ef6ab4c5115">&#9670;&#160;</a></span>get_p() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classtopology_1_1_vector2d.html">topology::Vector2d</a> &gt; group::get_p </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns member vector p_ (linear momenta). Length N. </p>

</div>
</div>
<a id="a0cdc0f913566c1551ec6c2a48ce7ea84" name="a0cdc0f913566c1551ec6c2a48ce7ea84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cdc0f913566c1551ec6c2a48ce7ea84">&#9670;&#160;</a></span>get_p() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtopology_1_1_vector2d.html">topology::Vector2d</a> group::get_p </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns linear momentum p_[i] of particle i. </p>

</div>
</div>
<a id="afe6b300a0569a60ed251d53f696ba403" name="afe6b300a0569a60ed251d53f696ba403"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe6b300a0569a60ed251d53f696ba403">&#9670;&#160;</a></span>get_r() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classtopology_1_1_vector2d.html">topology::Vector2d</a> &gt; group::get_r </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns member vector r_ (positions). Length N. </p>

</div>
</div>
<a id="a30b3c2277645a89660dcd569fd88128f" name="a30b3c2277645a89660dcd569fd88128f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30b3c2277645a89660dcd569fd88128f">&#9670;&#160;</a></span>get_r() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtopology_1_1_vector2d.html">topology::Vector2d</a> group::get_r </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns position r_[i] of particle i. </p>

</div>
</div>
<a id="a720506c44b273c3f667101135cc4ec0f" name="a720506c44b273c3f667101135cc4ec0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a720506c44b273c3f667101135cc4ec0f">&#9670;&#160;</a></span>get_sqrtN()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int group::get_sqrtN </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns sqrt of number of particles. </p>

</div>
</div>
<a id="a2012999a47b966f17c0cfff96a61ce69" name="a2012999a47b966f17c0cfff96a61ce69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2012999a47b966f17c0cfff96a61ce69">&#9670;&#160;</a></span>get_theta() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; group::get_theta </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns member vector theta_ (spin angles). Length N. </p>

</div>
</div>
<a id="a7d976ade405763f16dc7c3af8ea45e6f" name="a7d976ade405763f16dc7c3af8ea45e6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d976ade405763f16dc7c3af8ea45e6f">&#9670;&#160;</a></span>get_theta() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double group::get_theta </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns spin angle theta_[i] of particle i. </p>

</div>
</div>
<a id="a33626d82a7a15069d7263b95a78ca879" name="a33626d82a7a15069d7263b95a78ca879"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33626d82a7a15069d7263b95a78ca879">&#9670;&#160;</a></span>get_vm_eta()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double group::get_vm_eta </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns member variable vm_eta_ (Vicsek model noise strength) </p>

</div>
</div>
<a id="a830fc560e181d89475bee4743e7f64ff" name="a830fc560e181d89475bee4743e7f64ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a830fc560e181d89475bee4743e7f64ff">&#9670;&#160;</a></span>get_vm_v()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double group::get_vm_v </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns member variable vm_v_ (Vicsek model velocity) </p>

</div>
</div>
<a id="a7bde066b964a18a6866268119665d2db" name="a7bde066b964a18a6866268119665d2db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bde066b964a18a6866268119665d2db">&#9670;&#160;</a></span>get_volume()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double group::get_volume </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns volume. </p>

</div>
</div>
<a id="a04807e043673e16cc7dd41bc6a702e1c" name="a04807e043673e16cc7dd41bc6a702e1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04807e043673e16cc7dd41bc6a702e1c">&#9670;&#160;</a></span>get_w() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; group::get_w </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns member vector w_ (spin momenta). Length N. </p>

</div>
</div>
<a id="aa3e9c6c12977ede28d24ddd636f87eaa" name="aa3e9c6c12977ede28d24ddd636f87eaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3e9c6c12977ede28d24ddd636f87eaa">&#9670;&#160;</a></span>get_w() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double group::get_w </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns spin momentum w_[i] of particle i. </p>

</div>
</div>
<a id="a7c5201fa5923681c881093cac8ba27f2" name="a7c5201fa5923681c881093cac8ba27f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c5201fa5923681c881093cac8ba27f2">&#9670;&#160;</a></span>initialize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void group::initialize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classparameters.html">parameters</a> &amp;&#160;</td>
          <td class="paramname"><em>par</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes particle data for the group based on parameters given. </p>

</div>
</div>
<a id="a19ea7b028ce3882369b633f818baeb79" name="a19ea7b028ce3882369b633f818baeb79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19ea7b028ce3882369b633f818baeb79">&#9670;&#160;</a></span>initialize_random()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void group::initialize_random </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>kbT</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the mobile group with random particle positions and fills the partition. </p>

</div>
</div>
<a id="a1cde85b83583a5335dd4b422b690ab88" name="a1cde85b83583a5335dd4b422b690ab88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cde85b83583a5335dd4b422b690ab88">&#9670;&#160;</a></span>initialize_zero()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void group::initialize_zero </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets all particles to zero. </p>

</div>
</div>
<a id="a67f44a5b6756ace3cb9189b43048b4d2" name="a67f44a5b6756ace3cb9189b43048b4d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67f44a5b6756ace3cb9189b43048b4d2">&#9670;&#160;</a></span>J_pot()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double group::J_pot </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dist</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns spin interaction potential (distance-dependence) </p>

</div>
</div>
<a id="a0eb41a26ccb0d9ff0a675b2cf93c9e07" name="a0eb41a26ccb0d9ff0a675b2cf93c9e07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0eb41a26ccb0d9ff0a675b2cf93c9e07">&#9670;&#160;</a></span>J_pot_prime()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double group::J_pot_prime </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dist</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns derivative of spin interaction potential (distance-dependence) </p>

</div>
</div>
<a id="ab3a2b18c61a0d5d6b49d82e2ee968a14" name="ab3a2b18c61a0d5d6b49d82e2ee968a14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3a2b18c61a0d5d6b49d82e2ee968a14">&#9670;&#160;</a></span>J_pot_primeprime()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double group::J_pot_primeprime </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dist</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns second derivative of spin interaction potential (distance-dependence) </p>

</div>
</div>
<a id="a0636f5f5df62b94d68b16d0783ba9db8" name="a0636f5f5df62b94d68b16d0783ba9db8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0636f5f5df62b94d68b16d0783ba9db8">&#9670;&#160;</a></span>mom_to_zero()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void group::mom_to_zero </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets momenta to zero by shifts. </p>

</div>
</div>
<a id="adac1e7cbd401a8e1cb89aec29d022909" name="adac1e7cbd401a8e1cb89aec29d022909"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adac1e7cbd401a8e1cb89aec29d022909">&#9670;&#160;</a></span>operator*=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgroup.html">group</a> &amp; group::operator*= </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiplies particles by constant (used for adding time derivatives and such). </p>

</div>
</div>
<a id="a2dda93b15acd8592e527157f461b2d17" name="a2dda93b15acd8592e527157f461b2d17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dda93b15acd8592e527157f461b2d17">&#9670;&#160;</a></span>operator+=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgroup.html">group</a> &amp; group::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgroup.html">group</a> &amp;&#160;</td>
          <td class="paramname"><em>G</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds particle entries (used for adding time derivatives and such). </p>

</div>
</div>
<a id="a83cf3a22bf14d9583457f4a570095487" name="a83cf3a22bf14d9583457f4a570095487"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83cf3a22bf14d9583457f4a570095487">&#9670;&#160;</a></span>periodic_distance()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double group::periodic_distance </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns distance between particle i and j considering periodic boundaries (square box). Taking sqrt takes more time than returning the squared quantity by dist_periodic_squared. </p>

</div>
</div>
<a id="a9a39ffd1d945d3b2e29644cd8071c8d3" name="a9a39ffd1d945d3b2e29644cd8071c8d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a39ffd1d945d3b2e29644cd8071c8d3">&#9670;&#160;</a></span>periodic_distance_squared()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double group::periodic_distance_squared </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns squared distance between particle i and j considering periodic boundaries (square box). Squared function faster to calculate. </p>

</div>
</div>
<a id="ad2ac63201784cc0fe10ffec2f43dd502" name="ad2ac63201784cc0fe10ffec2f43dd502"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2ac63201784cc0fe10ffec2f43dd502">&#9670;&#160;</a></span>periodic_distance_vector()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtopology_1_1_vector2d.html">topology::Vector2d</a> group::periodic_distance_vector </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns distance vector between particle i and j considering periodic boundaries (square box). </p>

</div>
</div>
<a id="a0ac60bdc2adb8efbfae4753fa2b94e1d" name="a0ac60bdc2adb8efbfae4753fa2b94e1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ac60bdc2adb8efbfae4753fa2b94e1d">&#9670;&#160;</a></span>plaquette()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; group::plaquette </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the plaquette the particle i belongs to. i is in the lower left corner. Only works for lattice-based models. </p>

</div>
</div>
<a id="a245820fd75c41adc4bde3d49064d4763" name="a245820fd75c41adc4bde3d49064d4763"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a245820fd75c41adc4bde3d49064d4763">&#9670;&#160;</a></span>print_group()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void group::print_group </td>
          <td>(</td>
          <td class="paramtype">std::ofstream &amp;&#160;</td>
          <td class="paramname"><em>outputfile</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints the entire group to the outputfile. </p>

</div>
</div>
<a id="a86c12b188ea422afd8c14fdfd7ac8614" name="a86c12b188ea422afd8c14fdfd7ac8614"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86c12b188ea422afd8c14fdfd7ac8614">&#9670;&#160;</a></span>print_r()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void group::print_r </td>
          <td>(</td>
          <td class="paramtype">std::ofstream &amp;&#160;</td>
          <td class="paramname"><em>outputfile</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints only position coordinates of group to the outputfile. </p>

</div>
</div>
<a id="a8af680389fbe26cb2b6f98ba03b5628b" name="a8af680389fbe26cb2b6f98ba03b5628b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8af680389fbe26cb2b6f98ba03b5628b">&#9670;&#160;</a></span>r_to_lattice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void group::r_to_lattice </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets positions to lattice. Decides which lattice depending on lattice_type_ member variable. </p>

</div>
</div>
<a id="a7314ed0367730dd255506ef24e044d9f" name="a7314ed0367730dd255506ef24e044d9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7314ed0367730dd255506ef24e044d9f">&#9670;&#160;</a></span>r_to_squarelattice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void group::r_to_squarelattice </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets positions to square lattice. </p>

</div>
</div>
<a id="a048b170c8a1a823912103a846ac1e100" name="a048b170c8a1a823912103a846ac1e100"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a048b170c8a1a823912103a846ac1e100">&#9670;&#160;</a></span>r_to_trigonallattice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void group::r_to_trigonallattice </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets positions to trigonal lattice. CAREFUL! Trigonal lattice does not fit well into square box. </p>

</div>
</div>
<a id="a382d6fd08520e962a201f12d12784d96" name="a382d6fd08520e962a201f12d12784d96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a382d6fd08520e962a201f12d12784d96">&#9670;&#160;</a></span>randomize_particles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void group::randomize_particles </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>kbT</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets particles to random values. </p>

</div>
</div>
<a id="af4ee4dd785e2ba8a4167d8e82744cc68" name="af4ee4dd785e2ba8a4167d8e82744cc68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4ee4dd785e2ba8a4167d8e82744cc68">&#9670;&#160;</a></span>read_from_snapshot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void group::read_from_snapshot </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>snapshotname</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads coordinates and momenta from file snapshotname. </p>

</div>
</div>
<a id="ae039bc5e8e6d4c72cdc4883b7bebfe44" name="ae039bc5e8e6d4c72cdc4883b7bebfe44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae039bc5e8e6d4c72cdc4883b7bebfe44">&#9670;&#160;</a></span>scale_from_subgroup() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void group::scale_from_subgroup </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgroup.html">group</a> &amp;&#160;</td>
          <td class="paramname"><em>G</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Takes a subgroup (smaller group) and scales it up to the correct size of the group by copying. </p>
<p>Subgroups must be smaller by powers of 4. For proper results, this-object must be initialized. </p>

</div>
</div>
<a id="a736194a121584082de439cbcc4212007" name="a736194a121584082de439cbcc4212007"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a736194a121584082de439cbcc4212007">&#9670;&#160;</a></span>scale_from_subgroup() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void group::scale_from_subgroup </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>snapshotname</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a subgroup (smaller group) from a file and scales it up to the correct size of the group by copying. </p>
<p>Takes a subgroup (smaller group) and scales it up to the correct size of the group by copying. Subgroups must be smaller by powers of 4. For proper results, this-object must be initialized. Unlike the same function that takes a group as input, this function needs only a coordinate file. It is thus simpler to use. </p>

</div>
</div>
<a id="a92f337867f35fa669ef32e0f19f9dcae" name="a92f337867f35fa669ef32e0f19f9dcae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92f337867f35fa669ef32e0f19f9dcae">&#9670;&#160;</a></span>scale_mom()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void group::scale_mom </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scales all momenta (w_, p_) by a factor a. </p>

</div>
</div>
<a id="add61103bd8a398fe988671e776cc65d3" name="add61103bd8a398fe988671e776cc65d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add61103bd8a398fe988671e776cc65d3">&#9670;&#160;</a></span>set_all_p()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void group::set_all_p </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtopology_1_1_vector2d.html">topology::Vector2d</a>&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets all p to given value (useful for setting T = 0) </p>

</div>
</div>
<a id="afb305b904e93b3324b722955eaf3f0ab" name="afb305b904e93b3324b722955eaf3f0ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb305b904e93b3324b722955eaf3f0ab">&#9670;&#160;</a></span>set_all_theta()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void group::set_all_theta </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>theta</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets all theta to given value (useful for perfect spin alignment) </p>

</div>
</div>
<a id="af36d997bcec7a468eb5077cbcf447562" name="af36d997bcec7a468eb5077cbcf447562"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af36d997bcec7a468eb5077cbcf447562">&#9670;&#160;</a></span>set_all_w()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void group::set_all_w </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>w</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets all w to given value (useful for setting T = 0) </p>

</div>
</div>
<a id="a5441456cc9c95980636aedc16743147e" name="a5441456cc9c95980636aedc16743147e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5441456cc9c95980636aedc16743147e">&#9670;&#160;</a></span>set_p()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void group::set_p </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtopology_1_1_vector2d.html">topology::Vector2d</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gives p_ of particle i a specified value. </p>

</div>
</div>
<a id="a0d77c81ca4c869328301d258a2f2db97" name="a0d77c81ca4c869328301d258a2f2db97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d77c81ca4c869328301d258a2f2db97">&#9670;&#160;</a></span>set_particle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void group::set_particle </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtopology_1_1_vector2d.html">topology::Vector2d</a>&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtopology_1_1_vector2d.html">topology::Vector2d</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets all values theta_, w_, r_, p_ of particle i to the designated values. </p>

</div>
</div>
<a id="affd5de6e37800528eb15b3a842ebff48" name="affd5de6e37800528eb15b3a842ebff48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affd5de6e37800528eb15b3a842ebff48">&#9670;&#160;</a></span>set_px()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void group::set_px </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>px</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gives x-component of p_ of particle i a specified value. </p>

</div>
</div>
<a id="a249e0347dea0c41c4ef85fbd3b8002fd" name="a249e0347dea0c41c4ef85fbd3b8002fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a249e0347dea0c41c4ef85fbd3b8002fd">&#9670;&#160;</a></span>set_py()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void group::set_py </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>py</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gives y-component of p_ of particle i a specified value. </p>

</div>
</div>
<a id="adefa6aaedd0b7a04c87d660df2c86caf" name="adefa6aaedd0b7a04c87d660df2c86caf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adefa6aaedd0b7a04c87d660df2c86caf">&#9670;&#160;</a></span>set_r()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void group::set_r </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtopology_1_1_vector2d.html">topology::Vector2d</a>&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gives r_ of particle i a specified value. </p>

</div>
</div>
<a id="ae522a68e6bef63d88b00676da526d0d8" name="ae522a68e6bef63d88b00676da526d0d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae522a68e6bef63d88b00676da526d0d8">&#9670;&#160;</a></span>set_r_to_pbc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void group::set_r_to_pbc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets particle positions according to boundary conditions. </p>

</div>
</div>
<a id="a8989ee6be64dcfd8439978741da017ac" name="a8989ee6be64dcfd8439978741da017ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8989ee6be64dcfd8439978741da017ac">&#9670;&#160;</a></span>set_rx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void group::set_rx </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gives x-component of r_ of particle i a specified value. </p>

</div>
</div>
<a id="ae4443ab413d8a0fcd9ca2c52b04089c1" name="ae4443ab413d8a0fcd9ca2c52b04089c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4443ab413d8a0fcd9ca2c52b04089c1">&#9670;&#160;</a></span>set_ry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void group::set_ry </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gives y-component of r_ of particle i a specified value. </p>

</div>
</div>
<a id="a9e7b63db9ca781f493bc0f75007b2955" name="a9e7b63db9ca781f493bc0f75007b2955"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e7b63db9ca781f493bc0f75007b2955">&#9670;&#160;</a></span>set_temperature() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void group::set_temperature </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>kT</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Randomizes momenta to be in agreement with given kT of all particles. </p>

</div>
</div>
<a id="abccd24c6d129a82f51cab1efd36985dc" name="abccd24c6d129a82f51cab1efd36985dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abccd24c6d129a82f51cab1efd36985dc">&#9670;&#160;</a></span>set_temperature() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void group::set_temperature </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>kT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Randomizes momenta to be in agreement with given kT of particle i. </p>

</div>
</div>
<a id="aa992e216fef852d4a4584435cc7975cd" name="aa992e216fef852d4a4584435cc7975cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa992e216fef852d4a4584435cc7975cd">&#9670;&#160;</a></span>set_temperature_p() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void group::set_temperature_p </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>kT</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Randomizes linear momenta to be in agreement with given kT of all particles. </p>

</div>
</div>
<a id="a8495317d9d70b03975790d3fa24175c1" name="a8495317d9d70b03975790d3fa24175c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8495317d9d70b03975790d3fa24175c1">&#9670;&#160;</a></span>set_temperature_p() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void group::set_temperature_p </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>kT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Randomizes linear momenta to be in agreement with given kT of particle i. </p>

</div>
</div>
<a id="aafbf69c4c846604b010bd8558e656624" name="aafbf69c4c846604b010bd8558e656624"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafbf69c4c846604b010bd8558e656624">&#9670;&#160;</a></span>set_temperature_w() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void group::set_temperature_w </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>kT</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Randomizes spin momenta to be in agreement with given kT of all particles. </p>

</div>
</div>
<a id="a7f055b391a13687261ebe5d217acecc6" name="a7f055b391a13687261ebe5d217acecc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f055b391a13687261ebe5d217acecc6">&#9670;&#160;</a></span>set_temperature_w() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void group::set_temperature_w </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>kT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Randomizes spin momenta to be in agreement with given kT of particle i. </p>

</div>
</div>
<a id="a25ed6c689c762a5fa345526e66909285" name="a25ed6c689c762a5fa345526e66909285"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25ed6c689c762a5fa345526e66909285">&#9670;&#160;</a></span>set_theta()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void group::set_theta </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gives theta_ of particle i a specified value. </p>

</div>
</div>
<a id="af3fad0714000a544b77925ea7df44bbc" name="af3fad0714000a544b77925ea7df44bbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3fad0714000a544b77925ea7df44bbc">&#9670;&#160;</a></span>set_theta_to_interval()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void group::set_theta_to_interval </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets theta_ values to interval (-pi, pi) </p>

</div>
</div>
<a id="a1e06c0e58acfe9fef37b437065b06622" name="a1e06c0e58acfe9fef37b437065b06622"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e06c0e58acfe9fef37b437065b06622">&#9670;&#160;</a></span>set_w()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void group::set_w </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gives w_ of particle i a specified value. </p>

</div>
</div>
<a id="ac79ce6a5e76f29bd75c1c533fa22059e" name="ac79ce6a5e76f29bd75c1c533fa22059e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac79ce6a5e76f29bd75c1c533fa22059e">&#9670;&#160;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int group::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as <a class="el" href="classgroup.html#a0af365fff45f5342e94fee665b09fe38" title="Returns number of particles.">get_N()</a> </p>

</div>
</div>
<a id="ab399b20229d30669f7135bdcf50571d8" name="ab399b20229d30669f7135bdcf50571d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab399b20229d30669f7135bdcf50571d8">&#9670;&#160;</a></span>stream_along_spin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void group::stream_along_spin </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Streams along spin, r_new = r + v * spin(theta) </p>

</div>
</div>
<a id="a4b7c50f6a58e005e4224b06bdd3866bf" name="a4b7c50f6a58e005e4224b06bdd3866bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b7c50f6a58e005e4224b06bdd3866bf">&#9670;&#160;</a></span>sum_e_squared()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double group::sum_e_squared </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Total energy squared, basically N_&lt;e_i^2&gt;. Extensive. </p>

</div>
</div>
<a id="a0385b0d7559127fbfdc5b28b0ee18f1c" name="a0385b0d7559127fbfdc5b28b0ee18f1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0385b0d7559127fbfdc5b28b0ee18f1c">&#9670;&#160;</a></span>sum_eint_squared()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double group::sum_eint_squared </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interaction energy squared, basically N_&lt;e_{i,int}^2&gt;. Extensive. </p>

</div>
</div>
<a id="a503ead15968b11cd41ff36e0b2873d0f" name="a503ead15968b11cd41ff36e0b2873d0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a503ead15968b11cd41ff36e0b2873d0f">&#9670;&#160;</a></span>sum_ekin_squared()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double group::sum_ekin_squared </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Kinetic energy squared, basically N_&lt;e_{i,kin}^2&gt;. Extensive. </p>

</div>
</div>
<a id="aab1c1c3b62fc05dceb53e0c445c17d1c" name="aab1c1c3b62fc05dceb53e0c445c17d1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab1c1c3b62fc05dceb53e0c445c17d1c">&#9670;&#160;</a></span>sum_p()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtopology_1_1_vector2d.html">topology::Vector2d</a> group::sum_p </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Total momentum. Basically N_&lt;p&gt;. Extensive. </p>

</div>
</div>
<a id="ae8c5249e354de1d6388d3c3a2b92890c" name="ae8c5249e354de1d6388d3c3a2b92890c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8c5249e354de1d6388d3c3a2b92890c">&#9670;&#160;</a></span>sum_p_4()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double group::sum_p_4 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sum over momentum to the fourth power. Basically N_&lt;p^4&gt;. Extensive. </p>

</div>
</div>
<a id="aad244abed9cd7f87eaf339dd05e1343a" name="aad244abed9cd7f87eaf339dd05e1343a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad244abed9cd7f87eaf339dd05e1343a">&#9670;&#160;</a></span>sum_p_squared()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double group::sum_p_squared </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sum over momentum squared. Basically N_&lt;p^2&gt;. Extensive. </p>

</div>
</div>
<a id="a19d9795ec171a048475c9d5770bc4a50" name="a19d9795ec171a048475c9d5770bc4a50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19d9795ec171a048475c9d5770bc4a50">&#9670;&#160;</a></span>sum_s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtopology_1_1_vector2d.html">topology::Vector2d</a> group::sum_s </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Magnetization. Basically N_&lt;s&gt;. Extensive. </p>

</div>
</div>
<a id="a224b157d47ccae2095d7599e94fee0cf" name="a224b157d47ccae2095d7599e94fee0cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a224b157d47ccae2095d7599e94fee0cf">&#9670;&#160;</a></span>sum_s_4()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double group::sum_s_4 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Magnetization to the fourth power. Basically N_&lt;s&gt;^4. Extensive. </p>

</div>
</div>
<a id="a2c5591c152957f544ca88f3d728dd408" name="a2c5591c152957f544ca88f3d728dd408"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c5591c152957f544ca88f3d728dd408">&#9670;&#160;</a></span>sum_s_squared()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double group::sum_s_squared </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Magnetization squared. Basically N_&lt;s&gt;^2. Extensive. </p>

</div>
</div>
<a id="a51c3c0f31c8529456ae27f19a8572ec2" name="a51c3c0f31c8529456ae27f19a8572ec2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51c3c0f31c8529456ae27f19a8572ec2">&#9670;&#160;</a></span>sum_theta()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double group::sum_theta </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns sum over all theta, basically N_&lt;theta&gt;. Extensive. Probably pointless. </p>

</div>
</div>
<a id="a49290bb9d0172ccc094c7bd2c0809db1" name="a49290bb9d0172ccc094c7bd2c0809db1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49290bb9d0172ccc094c7bd2c0809db1">&#9670;&#160;</a></span>sum_w()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double group::sum_w </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns sum over omega, basically N_&lt;w&gt;. Extensive. </p>

</div>
</div>
<a id="a046fab9e71ff6a756d1ef405f1e9af0b" name="a046fab9e71ff6a756d1ef405f1e9af0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a046fab9e71ff6a756d1ef405f1e9af0b">&#9670;&#160;</a></span>sum_w_4()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double group::sum_w_4 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Omega to the fourth power, basically N_&lt;w^4&gt;. Proportional to kinetic energy. Extensive. </p>

</div>
</div>
<a id="af503088a31633fa02d12a5e3747bf741" name="af503088a31633fa02d12a5e3747bf741"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af503088a31633fa02d12a5e3747bf741">&#9670;&#160;</a></span>sum_w_squared()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double group::sum_w_squared </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Omega squared, basically N_&lt;w^2&gt;. Proportional to kinetic energy. Extensive. </p>

</div>
</div>
<a id="a278395747b1e8982e081e3af5fedcb75" name="a278395747b1e8982e081e3af5fedcb75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a278395747b1e8982e081e3af5fedcb75">&#9670;&#160;</a></span>theta_diff()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double group::theta_diff </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Difference in angles of two different particles. $\theta_{ij}$ in Bore paper. </p>

</div>
</div>
<a id="a9696e88dfbee235e456180afa2a73e14" name="a9696e88dfbee235e456180afa2a73e14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9696e88dfbee235e456180afa2a73e14">&#9670;&#160;</a></span>time_derivative()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgroup.html">group</a> group::time_derivative </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns time derivative of the entire group. </p>

</div>
</div>
<a id="a879ba3c38c405b39cdf3a404518019d5" name="a879ba3c38c405b39cdf3a404518019d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a879ba3c38c405b39cdf3a404518019d5">&#9670;&#160;</a></span>time_derivative_coord()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; group::time_derivative_coord </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns coordinate time derivative (first N_ entries are theta, then r_x, then r_y). </p>

</div>
</div>
<a id="a33234f8ffb4027528c50dedac6bec20a" name="a33234f8ffb4027528c50dedac6bec20a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33234f8ffb4027528c50dedac6bec20a">&#9670;&#160;</a></span>time_derivative_mom()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; group::time_derivative_mom </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns momenta time derivative (first N_ entries are omega, then p_x, then p_y). </p>

</div>
</div>
<a id="a400e7b2bf08f4480fb9a047003f2541e" name="a400e7b2bf08f4480fb9a047003f2541e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a400e7b2bf08f4480fb9a047003f2541e">&#9670;&#160;</a></span>time_derivative_p()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; group::time_derivative_p </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns p (linear momentum) time derivative. First N_ entries are x direction, N_+1 to 2N_ is y direction (splitting useful for leapfrog) </p>

</div>
</div>
<a id="ad9df3ca3f2cf67926b44db61a5218af0" name="ad9df3ca3f2cf67926b44db61a5218af0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9df3ca3f2cf67926b44db61a5218af0">&#9670;&#160;</a></span>time_derivative_r()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; group::time_derivative_r </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns r (particle position) time derivative. First N_ entries are x direction, N_+1 to 2N_ is y direction (splitting useful for leapfrog) </p>

</div>
</div>
<a id="a737b1562e521a90ceb6dd9630162a01d" name="a737b1562e521a90ceb6dd9630162a01d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a737b1562e521a90ceb6dd9630162a01d">&#9670;&#160;</a></span>time_derivative_theta()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; group::time_derivative_theta </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns theta (spin angle) time derivative (splitting useful for leapfrog) </p>

</div>
</div>
<a id="a982bd50ec79efd6e0d8a687b302e356e" name="a982bd50ec79efd6e0d8a687b302e356e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a982bd50ec79efd6e0d8a687b302e356e">&#9670;&#160;</a></span>time_derivative_w()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; group::time_derivative_w </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns omega (spin momentum) time derivative (splitting useful for leapfrog) </p>

</div>
</div>
<a id="a55e9bf8a5f8b9f1ee0b378f0ca2cfae0" name="a55e9bf8a5f8b9f1ee0b378f0ca2cfae0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55e9bf8a5f8b9f1ee0b378f0ca2cfae0">&#9670;&#160;</a></span>U_pot()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double group::U_pot </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dist</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns spatial interaction potential. </p>

</div>
</div>
<a id="a869674c0af745152011e6d628430dec2" name="a869674c0af745152011e6d628430dec2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a869674c0af745152011e6d628430dec2">&#9670;&#160;</a></span>U_pot_prime()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double group::U_pot_prime </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dist</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns derivative of spatial interaction potential. </p>

</div>
</div>
<a id="a76800935f2839e0e3f22b4910412ebec" name="a76800935f2839e0e3f22b4910412ebec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76800935f2839e0e3f22b4910412ebec">&#9670;&#160;</a></span>U_pot_primeprime()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double group::U_pot_primeprime </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dist</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns second derivative of spatial interaction potential. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a2c50b38ea116d7b21b34445836e85ee0" name="a2c50b38ea116d7b21b34445836e85ee0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c50b38ea116d7b21b34445836e85ee0">&#9670;&#160;</a></span>cutoff_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double group::cutoff_ = 1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interaction cutoff radius. </p>

</div>
</div>
<a id="abba72880d78720291cdd5267f96cebbf" name="abba72880d78720291cdd5267f96cebbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abba72880d78720291cdd5267f96cebbf">&#9670;&#160;</a></span>group_type_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string group::group_type_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Type of the group. Can be "xy" for the XY model, "mxy" for the mobile XY model, "fmxy" for a mobile XY model frozen in place, "vm" for the Vicsek model and "fvm" for the frozen (static) Vicsek model. </p>

</div>
</div>
<a id="a5e224ee273f6971cf0a76756c6c583f1" name="a5e224ee273f6971cf0a76756c6c583f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e224ee273f6971cf0a76756c6c583f1">&#9670;&#160;</a></span>I_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double group::I_ = 1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Spin inertia. </p>

</div>
</div>
<a id="a75137f8b271d5b73c441c88fabfe59d3" name="a75137f8b271d5b73c441c88fabfe59d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75137f8b271d5b73c441c88fabfe59d3">&#9670;&#160;</a></span>J_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double group::J_ = 1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Nearest neighbor interaction strength. </p>

</div>
</div>
<a id="a1fd5c592e393b150d715cf06cdcc3373" name="a1fd5c592e393b150d715cf06cdcc3373"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fd5c592e393b150d715cf06cdcc3373">&#9670;&#160;</a></span>L_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtopology_1_1_vector2d.html">topology::Vector2d</a> group::L_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Size of the box (some functions only defined for square boxes yet). </p>

</div>
</div>
<a id="a290ee2d978475279ecb2ee7b673d637f" name="a290ee2d978475279ecb2ee7b673d637f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a290ee2d978475279ecb2ee7b673d637f">&#9670;&#160;</a></span>lattice_type_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char group::lattice_type_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>lattice type. (type 's': square, type 't': trigonal, type 'n': none (mxy model etc)) </p>

</div>
</div>
<a id="a1a8b39fe4396923de757fa3071ec2f82" name="a1a8b39fe4396923de757fa3071ec2f82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a8b39fe4396923de757fa3071ec2f82">&#9670;&#160;</a></span>m_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double group::m_ = 1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mass. </p>

</div>
</div>
<a id="a0902e9bfec3a71e48d68db8f367d2228" name="a0902e9bfec3a71e48d68db8f367d2228"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0902e9bfec3a71e48d68db8f367d2228">&#9670;&#160;</a></span>N_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int group::N_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Size of the group. </p>

</div>
</div>
<a id="adf1af218f4fdaee805c20012d4305ab1" name="adf1af218f4fdaee805c20012d4305ab1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf1af218f4fdaee805c20012d4305ab1">&#9670;&#160;</a></span>nb_list_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classneighbor__list.html">neighbor_list</a>* group::nb_list_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>neighbor-list </p>

</div>
</div>
<a id="a15a89f93f15ae6e305944194244efc46" name="a15a89f93f15ae6e305944194244efc46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15a89f93f15ae6e305944194244efc46">&#9670;&#160;</a></span>nb_mult_factor_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double group::nb_mult_factor_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If neighbor rule leads to double counting, this factor has to be .5, otherwise 1. </p>

</div>
</div>
<a id="a03237769d3d2a8f936de6683f58d6810" name="a03237769d3d2a8f936de6683f58d6810"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03237769d3d2a8f936de6683f58d6810">&#9670;&#160;</a></span>nb_rule_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string group::nb_rule_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Neighbor calculation rule. Possible values: "bruteforce", "all", "ur" for full, (partition with) all and (partition with) upper right neighbors. </p>

</div>
</div>
<a id="a542a5c2dad5b7980cc0cfbf19a3b4ba6" name="a542a5c2dad5b7980cc0cfbf19a3b4ba6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a542a5c2dad5b7980cc0cfbf19a3b4ba6">&#9670;&#160;</a></span>p_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classtopology_1_1_vector2d.html">topology::Vector2d</a>&gt; group::p_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Particle momenta/velocities in the group. </p>

</div>
</div>
<a id="a187afae51fc68fd66b5c230d404cea0a" name="a187afae51fc68fd66b5c230d404cea0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a187afae51fc68fd66b5c230d404cea0a">&#9670;&#160;</a></span>partition_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpartition.html">partition</a> group::partition_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Partition (cell list) for neighborhood interaction. </p>

</div>
</div>
<a id="acbb3793a619f6fbf6f160d4a9a2f5487" name="acbb3793a619f6fbf6f160d4a9a2f5487"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbb3793a619f6fbf6f160d4a9a2f5487">&#9670;&#160;</a></span>r_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classtopology_1_1_vector2d.html">topology::Vector2d</a>&gt; group::r_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Particle positions in the group. </p>

</div>
</div>
<a id="ad5664d0f4bbf27f9f8cad68d333691e8" name="ad5664d0f4bbf27f9f8cad68d333691e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5664d0f4bbf27f9f8cad68d333691e8">&#9670;&#160;</a></span>sqrtN_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int group::sqrtN_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Square root of the group size (often useful). </p>

</div>
</div>
<a id="a44fc1d0e59c1401e62f98e0a4852b731" name="a44fc1d0e59c1401e62f98e0a4852b731"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44fc1d0e59c1401e62f98e0a4852b731">&#9670;&#160;</a></span>theta_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; group::theta_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Particle spin angles in the group. </p>

</div>
</div>
<a id="aeeaa72dd4e321200f4a9433fb3777098" name="aeeaa72dd4e321200f4a9433fb3777098"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeeaa72dd4e321200f4a9433fb3777098">&#9670;&#160;</a></span>U_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double group::U_ = 1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Spatial repulsion interaction strength. </p>

</div>
</div>
<a id="a47795c0f0f247447e23a541045e8116b" name="a47795c0f0f247447e23a541045e8116b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47795c0f0f247447e23a541045e8116b">&#9670;&#160;</a></span>vm_eta_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double group::vm_eta_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vicsek model parameter eta: Angle for random noise. </p>

</div>
</div>
<a id="ac960a4b811c77a828eff4f542d00d243" name="ac960a4b811c77a828eff4f542d00d243"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac960a4b811c77a828eff4f542d00d243">&#9670;&#160;</a></span>vm_v_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double group::vm_v_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vicsek model parameter v: Streaming velocity. </p>

</div>
</div>
<a id="a90512f77b5ad86c99a1b565078eaf537" name="a90512f77b5ad86c99a1b565078eaf537"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90512f77b5ad86c99a1b565078eaf537">&#9670;&#160;</a></span>w_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; group::w_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Particle spin momenta in the group. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="group_8h_source.html">group.h</a></li>
<li><a class="el" href="group_8cpp.html">group.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.7
</small></address>
</body>
</html>
