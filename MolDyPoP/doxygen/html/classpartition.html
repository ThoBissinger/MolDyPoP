<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MolDyPoP: partition Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="mperp_200.png"/></td>
  <td id="projectalign">
   <div id="projectname">MolDyPoP<span id="projectnumber">&#160;Version 2.0</span>
   </div>
   <div id="projectbrief">Molecular Dynamics for Polar Particle</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classpartition-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">partition Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Defines the partition class. The simulation box is partitioned into cells. The indices of a vector of particles (used for initialization) are sorted according to the cell they belong to. Has functions for printing and computing average velocities in a neighborhood.  
 <a href="classpartition.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="partition_8h_source.html">partition.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a84bdc6e3612b49c217d3af8709d9950c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpartition.html#a84bdc6e3612b49c217d3af8709d9950c">partition</a> ()</td></tr>
<tr class="memdesc:a84bdc6e3612b49c217d3af8709d9950c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty constructor.  <br /></td></tr>
<tr class="separator:a84bdc6e3612b49c217d3af8709d9950c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af23f6efe9fb8553ad105b0c1cbd84e58"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpartition.html#af23f6efe9fb8553ad105b0c1cbd84e58">partition</a> (const int &amp;N, const double &amp;cutoff, const <a class="el" href="classtopology_1_1_vector2d.html">topology::Vector2d</a> &amp;L)</td></tr>
<tr class="memdesc:af23f6efe9fb8553ad105b0c1cbd84e58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Standard constructor.  <br /></td></tr>
<tr class="separator:af23f6efe9fb8553ad105b0c1cbd84e58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2001d5ca72b2a0b2389cb1de1f5f72ef"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpartition.html#a2001d5ca72b2a0b2389cb1de1f5f72ef">partition</a> (const int &amp;N, const double &amp;cutoff, const <a class="el" href="classtopology_1_1_vector2d.html">topology::Vector2d</a> &amp;L, const std::vector&lt; <a class="el" href="classtopology_1_1_vector2d.html">topology::Vector2d</a> &gt; &amp;positions)</td></tr>
<tr class="memdesc:a2001d5ca72b2a0b2389cb1de1f5f72ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Standard constructor.  <br /></td></tr>
<tr class="separator:a2001d5ca72b2a0b2389cb1de1f5f72ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a462494343952d9aa3f655e88ad307869"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpartition.html#a462494343952d9aa3f655e88ad307869">~partition</a> ()</td></tr>
<tr class="memdesc:a462494343952d9aa3f655e88ad307869"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <br /></td></tr>
<tr class="separator:a462494343952d9aa3f655e88ad307869"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cb82599e45a4b61380f265d35cda7f6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpartition.html#a6cb82599e45a4b61380f265d35cda7f6">clear</a> ()</td></tr>
<tr class="memdesc:a6cb82599e45a4b61380f265d35cda7f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears all entries.  <br /></td></tr>
<tr class="separator:a6cb82599e45a4b61380f265d35cda7f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51558f8298d4f784778c08e1415e2bc0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpartition.html#a51558f8298d4f784778c08e1415e2bc0">fill</a> (const std::vector&lt; <a class="el" href="classtopology_1_1_vector2d.html">topology::Vector2d</a> &gt; &amp;positions)</td></tr>
<tr class="memdesc:a51558f8298d4f784778c08e1415e2bc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills the partition.  <br /></td></tr>
<tr class="separator:a51558f8298d4f784778c08e1415e2bc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92ae06eddd8fbfce504ff083bc366b9c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpartition.html#a92ae06eddd8fbfce504ff083bc366b9c">get_cellelem</a> (int m) const</td></tr>
<tr class="memdesc:a92ae06eddd8fbfce504ff083bc366b9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns int cellelem_[m].  <br /></td></tr>
<tr class="separator:a92ae06eddd8fbfce504ff083bc366b9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84b268598d837d11365b32098f0496b9"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpartition.html#a84b268598d837d11365b32098f0496b9">get_cellelem</a> () const</td></tr>
<tr class="memdesc:a84b268598d837d11365b32098f0496b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns vector cellelem_.  <br /></td></tr>
<tr class="separator:a84b268598d837d11365b32098f0496b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a2245031d405cc22386ba59b51a198a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpartition.html#a9a2245031d405cc22386ba59b51a198a">get_cellnum</a> () const</td></tr>
<tr class="memdesc:a9a2245031d405cc22386ba59b51a198a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns int cellnum_.  <br /></td></tr>
<tr class="separator:a9a2245031d405cc22386ba59b51a198a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75a02c785e995ce904c308a0b4554d38"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpartition.html#a75a02c785e995ce904c308a0b4554d38">get_cellvec</a> () const</td></tr>
<tr class="memdesc:a75a02c785e995ce904c308a0b4554d38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns vector cellvec.  <br /></td></tr>
<tr class="separator:a75a02c785e995ce904c308a0b4554d38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a252ece38cc3e5d461375f2330820edc4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpartition.html#a252ece38cc3e5d461375f2330820edc4">print</a> () const</td></tr>
<tr class="memdesc:a252ece38cc3e5d461375f2330820edc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print partition (only for troubleshooting).  <br /></td></tr>
<tr class="separator:a252ece38cc3e5d461375f2330820edc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6214a8a511adddff505fdc0c6c46c96f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpartition.html#a6214a8a511adddff505fdc0c6c46c96f">find_cell</a> (const <a class="el" href="classtopology_1_1_vector2d.html">topology::Vector2d</a> &amp;r) const</td></tr>
<tr class="memdesc:a6214a8a511adddff505fdc0c6c46c96f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the cell containing r.  <br /></td></tr>
<tr class="separator:a6214a8a511adddff505fdc0c6c46c96f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a515391400b1c41cbbf96e15d1d93009f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpartition.html#a515391400b1c41cbbf96e15d1d93009f">find_first</a> (int index) const</td></tr>
<tr class="memdesc:a515391400b1c41cbbf96e15d1d93009f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns index of the first element in cellvec_ pertaining to the cell with index index.  <br /></td></tr>
<tr class="separator:a515391400b1c41cbbf96e15d1d93009f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8928f60e124c54de74acc2f7e3f6fe28"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpartition.html#a8928f60e124c54de74acc2f7e3f6fe28">neighbor_cell</a> (int index, int lr, int du) const</td></tr>
<tr class="memdesc:a8928f60e124c54de74acc2f7e3f6fe28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns index of neighboring cell to cell at index. Uses periodic boundary conditions.  <br /></td></tr>
<tr class="separator:a8928f60e124c54de74acc2f7e3f6fe28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c48744f9ba92c6a52065e1b58cb5293"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpartition.html#a1c48744f9ba92c6a52065e1b58cb5293">neighbor_cell</a> (int index, int lr, int du, <a class="el" href="classtopology_1_1_vector2d.html">topology::Vector2d</a> &amp;shift) const</td></tr>
<tr class="memdesc:a1c48744f9ba92c6a52065e1b58cb5293"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns index of neighboring cell to cell at index. Uses periodic boundary conditions. Contains a shift.  <br /></td></tr>
<tr class="separator:a1c48744f9ba92c6a52065e1b58cb5293"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4a0c9068fdb50d14fdf245820260af3"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpartition.html#af4a0c9068fdb50d14fdf245820260af3">nb_cells_all</a> (int index, std::vector&lt; <a class="el" href="classtopology_1_1_vector2d.html">topology::Vector2d</a> &gt; &amp;shifts) const</td></tr>
<tr class="memdesc:af4a0c9068fdb50d14fdf245820260af3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns indices of all neighboring cells (including shifts)  <br /></td></tr>
<tr class="separator:af4a0c9068fdb50d14fdf245820260af3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b58fc3f63adc174bd2a26373a8d224c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpartition.html#a8b58fc3f63adc174bd2a26373a8d224c">nb_cells_all</a> (const <a class="el" href="classtopology_1_1_vector2d.html">topology::Vector2d</a> &amp;r, double cutoffsquared, std::vector&lt; <a class="el" href="classtopology_1_1_vector2d.html">topology::Vector2d</a> &gt; &amp;shifts) const</td></tr>
<tr class="memdesc:a8b58fc3f63adc174bd2a26373a8d224c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns indices of all neighboring cells (including shifts). Empty cells and cells out of reach of r are not included.  <br /></td></tr>
<tr class="separator:a8b58fc3f63adc174bd2a26373a8d224c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affbd8573230584e603d5468ee9af0f99"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpartition.html#affbd8573230584e603d5468ee9af0f99">nb_cells_ur</a> (int index, std::vector&lt; <a class="el" href="classtopology_1_1_vector2d.html">topology::Vector2d</a> &gt; &amp;shifts) const</td></tr>
<tr class="memdesc:affbd8573230584e603d5468ee9af0f99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns indices the neighboring cells above and right of the cell and the cell itself (including shifts). Can be used to avoid double counting.  <br /></td></tr>
<tr class="separator:affbd8573230584e603d5468ee9af0f99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b38f40fca8d908499ef31621aaf76db"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpartition.html#a6b38f40fca8d908499ef31621aaf76db">nb_cells_ur</a> (const <a class="el" href="classtopology_1_1_vector2d.html">topology::Vector2d</a> &amp;r, double cutoffsquared, std::vector&lt; <a class="el" href="classtopology_1_1_vector2d.html">topology::Vector2d</a> &gt; &amp;shifts) const</td></tr>
<tr class="memdesc:a6b38f40fca8d908499ef31621aaf76db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns indices the neighboring cells above and right of the cell and the cell itself (including shifts). Empty cells and cells out of reach of r are not included. Can be used to avoid double counting.  <br /></td></tr>
<tr class="separator:a6b38f40fca8d908499ef31621aaf76db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdeae6d64e9fd2d897e1a8f12bba9004"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtopology_1_1_vector2d.html">topology::Vector2d</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpartition.html#abdeae6d64e9fd2d897e1a8f12bba9004">corner</a> (int index, int lr, int ud) const</td></tr>
<tr class="memdesc:abdeae6d64e9fd2d897e1a8f12bba9004"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get position of a corner of a cell. Which corner is determined by lr, ud.  <br /></td></tr>
<tr class="separator:abdeae6d64e9fd2d897e1a8f12bba9004"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31ca932d9d0d564146b53222ecd5a028"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpartition.html#a31ca932d9d0d564146b53222ecd5a028">part_in_cell</a> (int index) const</td></tr>
<tr class="memdesc:a31ca932d9d0d564146b53222ecd5a028"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a std::vector containing the indices of the particles in the box with index 'index'.  <br /></td></tr>
<tr class="separator:a31ca932d9d0d564146b53222ecd5a028"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91e6d324b1ceba64a3230acb74488d3e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpartition.html#a91e6d324b1ceba64a3230acb74488d3e">nb_in_cell_index</a> (int index, const <a class="el" href="classtopology_1_1_vector2d.html">topology::Vector2d</a> &amp;r, double cutoffsquared, const std::vector&lt; <a class="el" href="classtopology_1_1_vector2d.html">topology::Vector2d</a> &gt; &amp;positions, std::vector&lt; double &gt; &amp;distances, const <a class="el" href="classtopology_1_1_vector2d.html">topology::Vector2d</a> shift=0) const</td></tr>
<tr class="memdesc:a91e6d324b1ceba64a3230acb74488d3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the indices of the particles in a cell for all particles within a cutoff radius of r.  <br /></td></tr>
<tr class="separator:a91e6d324b1ceba64a3230acb74488d3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae483486f45d3f0b4af19de5c44ad3a67"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpartition.html#ae483486f45d3f0b4af19de5c44ad3a67">nb_in_cell_index_above</a> (int index, const <a class="el" href="classtopology_1_1_vector2d.html">topology::Vector2d</a> &amp;r, double cutoffsquared, const std::vector&lt; <a class="el" href="classtopology_1_1_vector2d.html">topology::Vector2d</a> &gt; &amp;positions, std::vector&lt; double &gt; &amp;distances, const <a class="el" href="classtopology_1_1_vector2d.html">topology::Vector2d</a> shift=0) const</td></tr>
<tr class="memdesc:ae483486f45d3f0b4af19de5c44ad3a67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates only neighbors above particle (reduces computation time).  <br /></td></tr>
<tr class="separator:ae483486f45d3f0b4af19de5c44ad3a67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc5cb780680e20f628f528e24c2a68c5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpartition.html#adc5cb780680e20f628f528e24c2a68c5">cluster_analysis</a> (std::vector&lt; int &gt; &amp;cluster_sizes, std::vector&lt; int &gt; &amp;cluster_NoP, const int &amp;rho_min) const</td></tr>
<tr class="memdesc:adc5cb780680e20f628f528e24c2a68c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector of cluster sizes and the corresponding vector of the number of particles (NoP) per cluster. The variable rho_min determines the minimum number a cell has to contain to be considered part of a cluster.  <br /></td></tr>
<tr class="separator:adc5cb780680e20f628f528e24c2a68c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a940c5c9c9273ae4e36973b723a5c049d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpartition.html#a940c5c9c9273ae4e36973b723a5c049d">cluster_recursion</a> (int current_index, std::vector&lt; int &gt; indices, const int &amp;rho_min) const</td></tr>
<tr class="memdesc:a940c5c9c9273ae4e36973b723a5c049d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursive function, returns vector containing all the indices being part of a cluster. In principle, current_index is not necessary, one could also use the last entry of indices. But it doesn't disturb performance and is a little more readable.  <br /></td></tr>
<tr class="separator:a940c5c9c9273ae4e36973b723a5c049d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a012e617129e83630e0b96ee9db05501e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpartition.html#a012e617129e83630e0b96ee9db05501e">N_</a></td></tr>
<tr class="memdesc:a012e617129e83630e0b96ee9db05501e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of the group.  <br /></td></tr>
<tr class="separator:a012e617129e83630e0b96ee9db05501e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba95fa663a7ed0beef7c3b2d3572edd5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtopology_1_1_vector2d.html">topology::Vector2d</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpartition.html#aba95fa663a7ed0beef7c3b2d3572edd5">L_</a></td></tr>
<tr class="memdesc:aba95fa663a7ed0beef7c3b2d3572edd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of simulation box.  <br /></td></tr>
<tr class="separator:aba95fa663a7ed0beef7c3b2d3572edd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7ef9ece73f06d5a016057f571a8072a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtopology_1_1_vector2d.html">topology::Vector2d</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpartition.html#aa7ef9ece73f06d5a016057f571a8072a">cellwidth_</a></td></tr>
<tr class="memdesc:aa7ef9ece73f06d5a016057f571a8072a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Width of a cell in the cell list. Typically the cutoff radius of the interaction.  <br /></td></tr>
<tr class="separator:aa7ef9ece73f06d5a016057f571a8072a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac239d2426c0176e21713adcd96076f86"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpartition.html#ac239d2426c0176e21713adcd96076f86">M_</a> = std::vector&lt;int&gt;(2)</td></tr>
<tr class="memdesc:ac239d2426c0176e21713adcd96076f86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of cells per dimension. Dim = d = 2.  <br /></td></tr>
<tr class="separator:ac239d2426c0176e21713adcd96076f86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c07488276d1c962e5e4abafdb65406c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpartition.html#a5c07488276d1c962e5e4abafdb65406c">cellnum_</a></td></tr>
<tr class="memdesc:a5c07488276d1c962e5e4abafdb65406c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total number of cells.  <br /></td></tr>
<tr class="separator:a5c07488276d1c962e5e4abafdb65406c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad02cd6d63f434ff7043ce188f9784aed"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpartition.html#ad02cd6d63f434ff7043ce188f9784aed">firsts_</a></td></tr>
<tr class="memdesc:ad02cd6d63f434ff7043ce188f9784aed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indices of the first element pertaining to a cell. Dim = N_;.  <br /></td></tr>
<tr class="separator:ad02cd6d63f434ff7043ce188f9784aed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a784ac09035595f059405f2d1458ce7"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpartition.html#a6a784ac09035595f059405f2d1458ce7">cellelem_</a></td></tr>
<tr class="memdesc:a6a784ac09035595f059405f2d1458ce7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integers indicating the number of elements per cell. Dim = M_[0] * ... * M_[d];.  <br /></td></tr>
<tr class="separator:a6a784ac09035595f059405f2d1458ce7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac298b91a3d7bfef35b128b48c58a260b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpartition.html#ac298b91a3d7bfef35b128b48c58a260b">cellvec_</a></td></tr>
<tr class="memdesc:ac298b91a3d7bfef35b128b48c58a260b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector of particle indices. Dim = N_. Easier to access than the list, and since it has to be accessed a lot, we save it here.  <br /></td></tr>
<tr class="separator:ac298b91a3d7bfef35b128b48c58a260b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Defines the partition class. The simulation box is partitioned into cells. The indices of a vector of particles (used for initialization) are sorted according to the cell they belong to. Has functions for printing and computing average velocities in a neighborhood. </p>
<dl class="section author"><dt>Author</dt><dd>Thomas Bissinger</dd></dl>
<dl class="section note"><dt>Note</dt><dd>A previous version of this class used pointers to the actual particles instead of their indices. This was changed due to memory access problems. The code is also simpler. On the other hand, one has to store the particle indices and combine the stored indices with the actual vector to access elements. Therefore, some functions need the original particle vector as a call-by-reference input.</dd></dl>
<dl class="section date"><dt>Date</dt><dd>Created: late 2017, presumably </dd>
<dd>
Last Updated: 2023-08-06 </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a84bdc6e3612b49c217d3af8709d9950c" name="a84bdc6e3612b49c217d3af8709d9950c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84bdc6e3612b49c217d3af8709d9950c">&#9670;&#160;</a></span>partition() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">partition::partition </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Empty constructor. </p>

</div>
</div>
<a id="af23f6efe9fb8553ad105b0c1cbd84e58" name="af23f6efe9fb8553ad105b0c1cbd84e58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af23f6efe9fb8553ad105b0c1cbd84e58">&#9670;&#160;</a></span>partition() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">partition::partition </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>cutoff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtopology_1_1_vector2d.html">topology::Vector2d</a> &amp;&#160;</td>
          <td class="paramname"><em>L</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Standard constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td>Number of particles. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cutoff</td><td>Cutoff radius and width of cell. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">L</td><td>Size of simulation box, [0, L]. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2001d5ca72b2a0b2389cb1de1f5f72ef" name="a2001d5ca72b2a0b2389cb1de1f5f72ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2001d5ca72b2a0b2389cb1de1f5f72ef">&#9670;&#160;</a></span>partition() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">partition::partition </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>cutoff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtopology_1_1_vector2d.html">topology::Vector2d</a> &amp;&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classtopology_1_1_vector2d.html">topology::Vector2d</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>positions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Standard constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td>Number of particles. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cutoff</td><td>Cutoff radius and width of cell. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">L</td><td>Size of simulation box, [0, L]. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">positions</td><td>Vector of positions to be sorted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a462494343952d9aa3f655e88ad307869" name="a462494343952d9aa3f655e88ad307869"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a462494343952d9aa3f655e88ad307869">&#9670;&#160;</a></span>~partition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">partition::~partition </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a6cb82599e45a4b61380f265d35cda7f6" name="a6cb82599e45a4b61380f265d35cda7f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cb82599e45a4b61380f265d35cda7f6">&#9670;&#160;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void partition::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears all entries. </p>

</div>
</div>
<a id="adc5cb780680e20f628f528e24c2a68c5" name="adc5cb780680e20f628f528e24c2a68c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc5cb780680e20f628f528e24c2a68c5">&#9670;&#160;</a></span>cluster_analysis()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void partition::cluster_analysis </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>cluster_sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>cluster_NoP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>rho_min</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a vector of cluster sizes and the corresponding vector of the number of particles (NoP) per cluster. The variable rho_min determines the minimum number a cell has to contain to be considered part of a cluster. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cluster_sizes</td><td>Stores size (number of pertaining cells) of each cluster. std::vector&lt;int&gt; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cluster_NoP</td><td>Stores the number of particles of each cluster. std::vector&lt;int&gt; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rho_min</td><td>Minimal density of cluster, i.e. minimal number of particles in a cell to be considered part of the cluster. int</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The function was originally implemented to check for large number fluctuations in Visek swarms. Hasn't been used since preliminary tests in the early 2018s. Might be useful to someone, but not recommended for use by the author. Analyze particle clusters contained in the partition. </dd></dl>

</div>
</div>
<a id="a940c5c9c9273ae4e36973b723a5c049d" name="a940c5c9c9273ae4e36973b723a5c049d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a940c5c9c9273ae4e36973b723a5c049d">&#9670;&#160;</a></span>cluster_recursion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; partition::cluster_recursion </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>current_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>rho_min</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recursive function, returns vector containing all the indices being part of a cluster. In principle, current_index is not necessary, one could also use the last entry of indices. But it doesn't disturb performance and is a little more readable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">current_index</td><td>Index that is currently being viewed. int </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">indices</td><td>Indices that are already part of the cluster. std::vector&lt;int&gt; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rho_min</td><td>Minimal density of cluster, i.e. minimal number of particles in a cell to be considered part of the cluster. int Recursive function, finds all cells being part of a cluster. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abdeae6d64e9fd2d897e1a8f12bba9004" name="abdeae6d64e9fd2d897e1a8f12bba9004"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdeae6d64e9fd2d897e1a8f12bba9004">&#9670;&#160;</a></span>corner()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtopology_1_1_vector2d.html">topology::Vector2d</a> partition::corner </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ud</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get position of a corner of a cell. Which corner is determined by lr, ud. </p>

</div>
</div>
<a id="a51558f8298d4f784778c08e1415e2bc0" name="a51558f8298d4f784778c08e1415e2bc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51558f8298d4f784778c08e1415e2bc0">&#9670;&#160;</a></span>fill()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void partition::fill </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classtopology_1_1_vector2d.html">topology::Vector2d</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>positions</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fills the partition. </p>
<p>Assigns each particle to a cell in the partition.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">positions</td><td>Vector of positions to be sorted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6214a8a511adddff505fdc0c6c46c96f" name="a6214a8a511adddff505fdc0c6c46c96f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6214a8a511adddff505fdc0c6c46c96f">&#9670;&#160;</a></span>find_cell()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int partition::find_cell </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtopology_1_1_vector2d.html">topology::Vector2d</a> &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the index of the cell containing r. </p>
<dl class="section warning"><dt>Warning</dt><dd>Has no error output if r is not in the simulation box. </dd></dl>

</div>
</div>
<a id="a515391400b1c41cbbf96e15d1d93009f" name="a515391400b1c41cbbf96e15d1d93009f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a515391400b1c41cbbf96e15d1d93009f">&#9670;&#160;</a></span>find_first()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int partition::find_first </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns index of the first element in cellvec_ pertaining to the cell with index index. </p>

</div>
</div>
<a id="a84b268598d837d11365b32098f0496b9" name="a84b268598d837d11365b32098f0496b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84b268598d837d11365b32098f0496b9">&#9670;&#160;</a></span>get_cellelem() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; partition::get_cellelem </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns vector cellelem_. </p>

</div>
</div>
<a id="a92ae06eddd8fbfce504ff083bc366b9c" name="a92ae06eddd8fbfce504ff083bc366b9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92ae06eddd8fbfce504ff083bc366b9c">&#9670;&#160;</a></span>get_cellelem() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int partition::get_cellelem </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns int cellelem_[m]. </p>

</div>
</div>
<a id="a9a2245031d405cc22386ba59b51a198a" name="a9a2245031d405cc22386ba59b51a198a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a2245031d405cc22386ba59b51a198a">&#9670;&#160;</a></span>get_cellnum()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int partition::get_cellnum </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns int cellnum_. </p>

</div>
</div>
<a id="a75a02c785e995ce904c308a0b4554d38" name="a75a02c785e995ce904c308a0b4554d38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75a02c785e995ce904c308a0b4554d38">&#9670;&#160;</a></span>get_cellvec()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; partition::get_cellvec </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns vector cellvec. </p>

</div>
</div>
<a id="a8b58fc3f63adc174bd2a26373a8d224c" name="a8b58fc3f63adc174bd2a26373a8d224c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b58fc3f63adc174bd2a26373a8d224c">&#9670;&#160;</a></span>nb_cells_all() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; partition::nb_cells_all </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtopology_1_1_vector2d.html">topology::Vector2d</a> &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>cutoffsquared</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classtopology_1_1_vector2d.html">topology::Vector2d</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>shifts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns indices of all neighboring cells (including shifts). Empty cells and cells out of reach of r are not included. </p>

</div>
</div>
<a id="af4a0c9068fdb50d14fdf245820260af3" name="af4a0c9068fdb50d14fdf245820260af3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4a0c9068fdb50d14fdf245820260af3">&#9670;&#160;</a></span>nb_cells_all() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; partition::nb_cells_all </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classtopology_1_1_vector2d.html">topology::Vector2d</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>shifts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns indices of all neighboring cells (including shifts) </p>
<p>These functions could be used if the old index is known. But the comparisons it saves are probably similarly expensive as the modulus calculations necessary to return to the original index and check whether the index is still accurate. </p>

</div>
</div>
<a id="a6b38f40fca8d908499ef31621aaf76db" name="a6b38f40fca8d908499ef31621aaf76db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b38f40fca8d908499ef31621aaf76db">&#9670;&#160;</a></span>nb_cells_ur() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; partition::nb_cells_ur </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtopology_1_1_vector2d.html">topology::Vector2d</a> &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>cutoffsquared</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classtopology_1_1_vector2d.html">topology::Vector2d</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>shifts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns indices the neighboring cells above and right of the cell and the cell itself (including shifts). Empty cells and cells out of reach of r are not included. Can be used to avoid double counting. </p>

</div>
</div>
<a id="affbd8573230584e603d5468ee9af0f99" name="affbd8573230584e603d5468ee9af0f99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affbd8573230584e603d5468ee9af0f99">&#9670;&#160;</a></span>nb_cells_ur() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; partition::nb_cells_ur </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classtopology_1_1_vector2d.html">topology::Vector2d</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>shifts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns indices the neighboring cells above and right of the cell and the cell itself (including shifts). Can be used to avoid double counting. </p>

</div>
</div>
<a id="a91e6d324b1ceba64a3230acb74488d3e" name="a91e6d324b1ceba64a3230acb74488d3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91e6d324b1ceba64a3230acb74488d3e">&#9670;&#160;</a></span>nb_in_cell_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; partition::nb_in_cell_index </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtopology_1_1_vector2d.html">topology::Vector2d</a> &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>cutoffsquared</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classtopology_1_1_vector2d.html">topology::Vector2d</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>positions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>distances</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtopology_1_1_vector2d.html">topology::Vector2d</a>&#160;</td>
          <td class="paramname"><em>shift</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the indices of the particles in a cell for all particles within a cutoff radius of r. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>Cell index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">r</td><td>Position of particle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cutoffsquared</td><td>Square of the cutoff radius (square because no roots have to be taken). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">positions</td><td>Vector of positions to be accessed. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">distances</td><td>Stores the distances to all neighbors. Saves computation time. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">shift</td><td>Shifts position of vector r. Optional, default is 0.</td></tr>
  </table>
  </dd>
</dl>
<p>ATTENTION: The integer neighbors is not re-initialized, so the number of neighbors is added to the value that is already stored in neighbors. This simplifies calculations with more than one group, but one has to bear that in mind. </p>

</div>
</div>
<a id="ae483486f45d3f0b4af19de5c44ad3a67" name="ae483486f45d3f0b4af19de5c44ad3a67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae483486f45d3f0b4af19de5c44ad3a67">&#9670;&#160;</a></span>nb_in_cell_index_above()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; partition::nb_in_cell_index_above </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtopology_1_1_vector2d.html">topology::Vector2d</a> &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>cutoffsquared</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classtopology_1_1_vector2d.html">topology::Vector2d</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>positions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>distances</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtopology_1_1_vector2d.html">topology::Vector2d</a>&#160;</td>
          <td class="paramname"><em>shift</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates only neighbors above particle (reduces computation time). </p>

</div>
</div>
<a id="a8928f60e124c54de74acc2f7e3f6fe28" name="a8928f60e124c54de74acc2f7e3f6fe28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8928f60e124c54de74acc2f7e3f6fe28">&#9670;&#160;</a></span>neighbor_cell() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int partition::neighbor_cell </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>du</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns index of neighboring cell to cell at index. Uses periodic boundary conditions. </p>
<p>lr and ur are used to describe where the neighboring cell is. E.g. a cell to the top left would correspond to lr = -1 (left) and ud = 1 (up). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>index of cell. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lr</td><td>neighboring cell position in left-right (x) direction. In {-1,0,1}. -1 is left. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">du</td><td>neighboring cell position in down-up (y) direction. In {-1,0,1}. -1 is down. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1c48744f9ba92c6a52065e1b58cb5293" name="a1c48744f9ba92c6a52065e1b58cb5293"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c48744f9ba92c6a52065e1b58cb5293">&#9670;&#160;</a></span>neighbor_cell() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int partition::neighbor_cell </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>du</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtopology_1_1_vector2d.html">topology::Vector2d</a> &amp;&#160;</td>
          <td class="paramname"><em>shift</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns index of neighboring cell to cell at index. Uses periodic boundary conditions. Contains a shift. </p>
<p>lr and ur are used to describe where the neighboring cell is. E.g. a cell to the top left would correspond to lr = -1 (left) and ud = 1 (up). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>index of cell. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lr</td><td>neighboring cell position in left-right (x) direction. In {-1,0,1} = (left, center, right). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">du</td><td>neighboring cell position in down-up (y) direction. In {-1,0,1} = (below, center, above). </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">shift</td><td>if the neighboring cell is on the other side of the periodic box, a nonzero shift is stored here. The shift is designed such that the cell at index is next to its neighboring cell if shift is subtracted from the positions of all particles in the cell at index. (Later function calls with r-shift) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a31ca932d9d0d564146b53222ecd5a028" name="a31ca932d9d0d564146b53222ecd5a028"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31ca932d9d0d564146b53222ecd5a028">&#9670;&#160;</a></span>part_in_cell()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; partition::part_in_cell </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a std::vector containing the indices of the particles in the box with index 'index'. </p>

</div>
</div>
<a id="a252ece38cc3e5d461375f2330820edc4" name="a252ece38cc3e5d461375f2330820edc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a252ece38cc3e5d461375f2330820edc4">&#9670;&#160;</a></span>print()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void partition::print </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print partition (only for troubleshooting). </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a6a784ac09035595f059405f2d1458ce7" name="a6a784ac09035595f059405f2d1458ce7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a784ac09035595f059405f2d1458ce7">&#9670;&#160;</a></span>cellelem_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;int&gt; partition::cellelem_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Integers indicating the number of elements per cell. Dim = M_[0] * ... * M_[d];. </p>

</div>
</div>
<a id="a5c07488276d1c962e5e4abafdb65406c" name="a5c07488276d1c962e5e4abafdb65406c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c07488276d1c962e5e4abafdb65406c">&#9670;&#160;</a></span>cellnum_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int partition::cellnum_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Total number of cells. </p>

</div>
</div>
<a id="ac298b91a3d7bfef35b128b48c58a260b" name="ac298b91a3d7bfef35b128b48c58a260b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac298b91a3d7bfef35b128b48c58a260b">&#9670;&#160;</a></span>cellvec_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;int&gt; partition::cellvec_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector of particle indices. Dim = N_. Easier to access than the list, and since it has to be accessed a lot, we save it here. </p>

</div>
</div>
<a id="aa7ef9ece73f06d5a016057f571a8072a" name="aa7ef9ece73f06d5a016057f571a8072a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7ef9ece73f06d5a016057f571a8072a">&#9670;&#160;</a></span>cellwidth_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtopology_1_1_vector2d.html">topology::Vector2d</a> partition::cellwidth_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Width of a cell in the cell list. Typically the cutoff radius of the interaction. </p>

</div>
</div>
<a id="ad02cd6d63f434ff7043ce188f9784aed" name="ad02cd6d63f434ff7043ce188f9784aed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad02cd6d63f434ff7043ce188f9784aed">&#9670;&#160;</a></span>firsts_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;int&gt; partition::firsts_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indices of the first element pertaining to a cell. Dim = N_;. </p>
<p>Set to the first element of the next cell if the cell is empty. </p>

</div>
</div>
<a id="aba95fa663a7ed0beef7c3b2d3572edd5" name="aba95fa663a7ed0beef7c3b2d3572edd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba95fa663a7ed0beef7c3b2d3572edd5">&#9670;&#160;</a></span>L_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtopology_1_1_vector2d.html">topology::Vector2d</a> partition::L_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Size of simulation box. </p>
<p>Box has to be at least twice the size of the cutoff radius, else particles can have double-interaction. This case is not an error caught by the simulation so far. Note that the simulation box is from 0 to L_. </p>

</div>
</div>
<a id="ac239d2426c0176e21713adcd96076f86" name="ac239d2426c0176e21713adcd96076f86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac239d2426c0176e21713adcd96076f86">&#9670;&#160;</a></span>M_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;int&gt; partition::M_ = std::vector&lt;int&gt;(2)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of cells per dimension. Dim = d = 2. </p>

</div>
</div>
<a id="a012e617129e83630e0b96ee9db05501e" name="a012e617129e83630e0b96ee9db05501e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a012e617129e83630e0b96ee9db05501e">&#9670;&#160;</a></span>N_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int partition::N_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Size of the group. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="partition_8h_source.html">partition.h</a></li>
<li><a class="el" href="partition_8cpp.html">partition.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.7
</small></address>
</body>
</html>
